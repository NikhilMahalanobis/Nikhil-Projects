0027D382 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/17/2022 11:43:08 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Interactive Assembly Assignment
00000000                             3  * Written by : Nikhil Mahalanobis
00000000                             4  * Date       : 10/18/2021
00000000                             5  * Description:  This Interactive Assembly Assignment is a "game" where the player must shoot the aliens 
00000000                             6  *               heading towards them a certain amount of times (15) before the alien reaches the bottom of the screen. 
00000000                             7  *               The alien spawns in a random position along the top side of the screen, and every time one is destroyed,
00000000                             8  *               acceleration is applied and the velocity increases every iteration. 
00000000                             9  *               
00000000                            10  *               This program is made up of several other files that manage the different parts of the game including:
00000000                            11  *               Player.x68 - File that handles the creation, input, and drawing of the player
00000000                            12  *               Bullet.x68 - File that handles the creation, movement, and drawing of the bullet the player can shoot
00000000                            13  *               Alien.x68 - File that handels the creation, movement, drawing, of the Alien the player has to shoot, as well as keeping track of score
00000000                            14  *               LED.x68 - File that handles the drawing and updating of a seven segment LED, that indicates the current score to the player, which also affects the win/lose condition
00000000                            15  *
00000000                            16  *
00000000                            17  * CONTROLS: A/D - Move left/right respectively
00000000                            18  *           Space - Shoot bullet 
00000000                            19  *
00000000                            20  *
00000000                            21  * OBJECTIVE: Don't let the Alien get to the end of the screen!
00000000                            22  *-----------------------------------------------------------
00000000                            23      
00000000                            24      
00001000                            25      ORG    $1000
00001000                            26  
00001000                            27      INCLUDE "Player.x68"
00001000                            28  
00001000  =00000050                 29  SET_PEN_COLOR_COMMAND equ 80
00001000  =00000051                 30  SET_FILL_COLOR_COMMAND equ 81
00001000  =00000057                 31  DRAW_RECTANGLE_COMMAND equ 87
00001000  =00000013                 32  GET_USER_INPUT_COMMAND equ 19
00001000                            33  
00001000  =00000014                 34  PLAYER_WIDTH equ 20
00001000  =00000014                 35  PLAYER_HEIGHT equ 20
00001000  =0001B350                 36  PLAYER_TOP_Y_POSITION equ 111440
00001000  =00000028                 37  PLAYER_STARTING_X_POSITION equ 40
00001000  =00000023                 38  PLAYER_RIGHT_VELOCITY equ 35
00001000  =FFFFFFDD                 39  PLAYER_LEFT_VELOCITY equ -35
00001000  =00000280                 40  RIGHT_SIDE_OF_SCREEN equ 640
00001000                            41  
00001000  =00FFFFFF                 42  WHITE equ $00FFFFFF
00001000  =00FF0000                 43  BLUE equ $00FF0000
00001000                            44  
00001000                            45  initPlayer
00001000                            46      *init x position
00001000  7E28                      47      move.l #PLAYER_STARTING_X_POSITION, d7
00001002                            48      
00001002                            49      *set ball y position and height
00001002  243C 01B35000             50      move.l #PLAYER_TOP_Y_POSITION<<8, d2
00001008  2802                      51      move.l d2, d4
0000100A  0684 00000014             52      add.l #PLAYER_HEIGHT, d4
00001010                            53      
00001010                            54      *init the number of bullets to 0 since we don't have any yet
00001010  43F9 0000114E             55      lea numBullets, a1
00001016  22BC 00000000             56      move.l #0, (a1)
0000101C                            57  
0000101C  4E75                      58      rts
0000101E                            59  
0000101E                            60  updatePlayer: 
0000101E                            61      *If the player presses the 'D' key, call the function to move player object right
0000101E  7244                      62      move.l #'D', d1
00001020  103C 0013                 63      move.b #GET_USER_INPUT_COMMAND, d0
00001024  4E4F                      64      trap #15
00001026  2A01                      65      move.l d1, d5
00001028  0285 000000FF             66      andi.l #$FF, d5
0000102E  6600 0040                 67      bne dPressed
00001032                            68      
00001032                            69      *If the player presses the 'A' key, call the function to move player object left
00001032  7241                      70      move.l #'A', d1
00001034  103C 0013                 71      move.b #GET_USER_INPUT_COMMAND, d0
00001038  4E4F                      72      trap #15
0000103A  2A01                      73      move.l d1, d5
0000103C  0285 000000FF             74      andi.l #$FF, d5
00001042  6600 003C                 75      bne aPressed
00001046                            76      
00001046                            77      *Check to see if space was already pressed the previous frame before. If it was, don't detect input from space this iteration of the update
00001046                            78      *This is because when a button is pressed, Easy68K detects the input for multiple frames, so the bullets were getting spammed too much
00001046                            79      *This gets rid of the spam issue, and forces the user to shoot 1 bullet at a given time
00001046  4241                      80      clr d1
00001048  43F9 0000114E             81      lea numBullets, a1
0000104E  2211                      82      move.l (a1), d1
00001050  0C81 00000001             83      cmpi.l #1, d1
00001056  6700 008E                 84      beq return
0000105A                            85     
0000105A                            86      *If the player presses 'Space', call function to shoot bullet
0000105A  7220                      87      move.l #$20, d1
0000105C  103C 0013                 88      move.b #GET_USER_INPUT_COMMAND, d0
00001060  4E4F                      89      trap #15
00001062  2A01                      90      move.l d1, d5
00001064  0285 000000FF             91      andi.l #$FF, d5
0000106A  6600 0024                 92      bne spacePressed
0000106E                            93      
0000106E  4E75                      94      rts
00001070                            95      
00001070                            96  dPressed:
00001070                            97      *Add right velocity to the current player position to get the new position
00001070  7C23                      98      move.l #PLAYER_RIGHT_VELOCITY, d6
00001072  DE86                      99      add.l d6, d7
00001074                           100      
00001074                           101      *Compare the new position to our screen bounds. If it's too big, we have to undo the last addition we made
00001074  0C87 00026C00            102      cmpi.l #(RIGHT_SIDE_OF_SCREEN-PLAYER_WIDTH)<<8, d7
0000107A  6C00 005A                103      bge subtractOne
0000107E  4E75                     104      rts
00001080                           105  
00001080                           106  aPressed:
00001080                           107      *Add left velocity to current player position to get new position
00001080  7CDD                     108      move.l #PLAYER_LEFT_VELOCITY, d6
00001082  DE86                     109      add.l d6, d7
00001084                           110      
00001084                           111      *Compare new position to screen bounds. If it's too small, undo the last addition we made
00001084  0C87 00000028            112      cmpi.l #PLAYER_STARTING_X_POSITION, d7
0000108A  6F00 0052                113      ble addOne
0000108E  4E75                     114      rts
00001090                           115  
00001090                           116  spacePressed:
00001090                           117      *Load the bullet's coordinate table, the number of bullets, and the bulletActive flag
00001090  43F9 00001152            118      lea bulletTableX1, a1
00001096  45F9 000011F2            119      lea bulletTableY1, a2
0000109C  47F9 000011A2            120      lea bulletTableX2, a3
000010A2  49F9 00001242            121      lea bulletTableY2, a4
000010A8  4BF9 0000114E            122      lea numBullets, a5
000010AE  4DF9 00001292            123      lea bulletActive, a6
000010B4                           124      
000010B4                           125      ;Shift to get the X coordinate of the player, which is used to init the X coordinate of the bullet when fired
000010B4  2207                     126      move.l d7, d1
000010B6  E081                     127      asr.l #8, d1
000010B8  2601                     128      move.l d1, d3
000010BA  0683 00000014            129      add.l #PLAYER_WIDTH, d3
000010C0                           130      
000010C0                           131      ;Move the players current position to the Bullet Coordinate tables, so we can init the bullet position relative to the player
000010C0  22C1                     132      move.l d1, (a1)+
000010C2  24C2                     133      move.l d2, (a2)+
000010C4  26C3                     134      move.l d3, (a3)+
000010C6  28C4                     135      move.l d4, (a4)+
000010C8                           136      
000010C8                           137      ;Add 1 to number of bullets
000010C8  2C15                     138      move.l (a5), d6
000010CA  5286                     139      addi.l #1, d6
000010CC  2A86                     140      move.l d6, (a5)
000010CE                           141      
000010CE                           142      ;Change value of bulletActive flag so we know we're firing a shot
000010CE  2CBC 00000001            143      move.l #1, (a6)
000010D4                           144      
000010D4  4E75                     145      rts
000010D6                           146  
000010D6                           147  subtractOne:
000010D6  0487 00000023            148      subi.l #PLAYER_RIGHT_VELOCITY, d7
000010DC  4E75                     149      rts
000010DE                           150  addOne:
000010DE  0687 00000023            151      addi.l #-PLAYER_LEFT_VELOCITY, d7
000010E4  4E75                     152      rts
000010E6                           153  return:
000010E6  4E75                     154      rts
000010E8                           155  
000010E8                           156  drawPlayer:
000010E8  223C 00FF0000            157      move.l #BLUE, d1
000010EE  103C 0050                158      move.b #SET_PEN_COLOR_COMMAND, d0
000010F2  4E4F                     159      trap #15
000010F4  103C 0051                160      move.b #SET_FILL_COLOR_COMMAND, d0
000010F8  4E4F                     161      trap #15
000010FA  103C 0057                162      move.b #DRAW_RECTANGLE_COMMAND, d0
000010FE                           163      
000010FE                           164      *Shift to get the value of the X coordinates since we're using fixed point math
000010FE  2207                     165      move.l d7, d1
00001100  E081                     166      asr.l #8, d1
00001102  2601                     167      move.l d1, d3
00001104  0683 00000014            168      add.l #PLAYER_WIDTH, d3
0000110A                           169      
0000110A                           170      *Shift to get the value of the Y coordinates since we're using fixed point math
0000110A  E082                     171      asr.l #8, d2
0000110C  2802                     172      move.l d2, d4
0000110E  0684 00000014            173      add.l #PLAYER_HEIGHT, d4
00001114  4E4F                     174      trap #15
00001116                           175      
00001116                           176      *Reset the players Y position
00001116  243C 0001B350            177      move.l #PLAYER_TOP_Y_POSITION,d2
0000111C                           178      
0000111C                           179      *Store the value of the current position of player in table
0000111C  43F9 0000113E            180      lea playerX1, a1
00001122  45F9 00001142            181      lea playerX2, a2
00001128  47F9 00001146            182      lea playerY1, a3
0000112E  49F9 0000114A            183      lea playerY2, a4
00001134  2281                     184      move.l d1, (a1)
00001136  2483                     185      move.l d3, (a2)
00001138  2682                     186      move.l d2, (a3)
0000113A  2884                     187      move.l d4, (a4)
0000113C                           188     
0000113C  4E75                     189      rts
0000113E                           190  
0000113E                           191  playerX1 ds.l 1
00001142                           192  playerX2 ds.l 1
00001146                           193  playerY1 ds.l 1
0000114A                           194  playerY2 ds.l 1
0000114E                           195  
0000114E                           196  numBullets ds.l 1
00001152                           197  
00001152                           198  bulletTableX1 ds.l 20
000011A2                           199  bulletTableX2 ds.l 20
000011F2                           200  bulletTableY1 ds.l 20
00001242                           201  bulletTableY2 ds.l 20 
00001292                           202  
00001292= 00000000                 203  bulletActive dc.l 0
00001296                           204  
00001296                           205  
00001296                           206  
00001296                           207  
00001296                           208  
00001296                           209  
00001296                           210  
00001296                           211  
00001296                           212  
00001296                           213  
00001296                           214  
00001296                           215  
00001296                           216  
00001296                           217  
00001296                           218  
00001296                           219  
00001296                           220  -------------------- end include --------------------
00001296                           221      INCLUDE "Bullet.x68"
00001296                           222  
00001296                           223  ALL_REG reg D0-D7/A0-A6
00001296                           224  
00001296                           225  ;Trap code commands for Bullet
00001296  =00000050                226  SET_PEN_COLOR_COMMAND equ 80
00001296  =00000051                227  SET_FILL_COLOR_COMMAND equ 81
00001296  =00000058                228  DRAW_CIRCLE_COMMAND equ 88
00001296  =00000013                229  GET_USER_INPUT_COMMAND equ 19
00001296                           230  
00001296                           231  ;EQU values for player height/width, starting position, boundaries, and velocity
00001296  =00000010                232  BULLET_WIDTH equ 16
00001296  =00000010                233  BULLET_HEIGHT equ 16
00001296  =0001B328                234  BULLET_TOP_Y_POSITION equ 111400
00001296  =00000028                235  BULLET_STARTING_X_POSITION equ 40
00001296  =0000002D                236  BULLET_VELOCITY equ 45
00001296  =00000001                237  BULLET_ACCELERATION equ 1
00001296  =00000000                238  TOP_SIDE_OF_SCREEN equ 0
00001296                           239  
00001296  =00800080                240  PURPLE equ $00800080
00001296                           241  
00001296                           242  checkNumBullets:  
00001296  48E7 FFFE                243      movem.l ALL_REG, -(sp)
0000129A                           244    
0000129A                           245      *Compare numBullets to 0. If not 0, then we must update/draw bullets
0000129A  43F8 114E                246      lea numBullets, a1
0000129E  2A11                     247      move.l (a1), d5
000012A0  0C85 00000000            248      cmpi.l #0, d5
000012A6                           249      
000012A6  4CDF 7FFF                250      movem.l (sp)+, ALL_REG
000012AA  4E75                     251      rts
000012AC                           252   
000012AC                           253  updateBullet:
000012AC  48E7 FFFE                254      movem.l ALL_REG, -(sp)
000012B0                           255      
000012B0                           256      *Get current Y coordinate of the bullet, and add velocity to change position
000012B0  43F8 11F2                257      lea bulletTableY1, a1
000012B4  45F8 1152                258      lea bulletTableX1, a2
000012B8  7A2D                     259      move.l #BULLET_VELOCITY, d5
000012BA  2C11                     260      move.l (a1), d6
000012BC  9C85                     261      sub.l d5,d6
000012BE                           262  
000012BE                           263     *Comparison to make sure we don't go beyond the bounds of the top of the screen
000012BE                           264     *If we do, delete the bulelt
000012BE  0C86 00000000            265      cmpi.l #(TOP_SIDE_OF_SCREEN)<<8, d6
000012C4  6F00 005C                266      ble deleteBullet
000012C8                           267      
000012C8  0C92 0000002D            268      cmpi.l #45, (a2)
000012CE  6F00 0052                269      ble deleteBullet
000012D2                           270      
000012D2                           271  returnFromDelete:
000012D2  22C6                     272      move.l d6, (a1)+
000012D4                           273          
000012D4  4CDF 7FFF                274      movem.l (sp)+,ALL_REG
000012D8                           275      
000012D8  4E75                     276      rts 
000012DA                           277              
000012DA                           278  drawBullet:
000012DA  48E7 FFFE                279      movem.l ALL_REG, -(sp)
000012DE                           280      
000012DE  223C 00800080            281      move.l #PURPLE, d1
000012E4  103C 0050                282      move.b #SET_PEN_COLOR_COMMAND, d0
000012E8  4E4F                     283      trap #15
000012EA  103C 0051                284      move.b #SET_FILL_COLOR_COMMAND, d0
000012EE  4E4F                     285      trap #15
000012F0                           286      
000012F0                           287      *Load the bullet's coordinates from the table, shift accordingly due to fixed point,
000012F0                           288      *and draw the bullet at the current positio
000012F0  103C 0058                289      move.b #DRAW_CIRCLE_COMMAND, d0
000012F4  43F8 1152                290      lea bulletTableX1, a1
000012F8  45F8 11F2                291      lea bulletTableY1, a2
000012FC  47F8 11A2                292      lea bulletTableX2, a3
00001300  49F8 1242                293      lea bulletTableY2, a4    
00001304  2211                     294      move.l (a1), d1
00001306  2412                     295      move.l (a2), d2
00001308  E082                     296      asr.l #8, d2
0000130A  2802                     297      move.l d2, d4
0000130C  0684 00000010            298      add.l #BULLET_HEIGHT, d4
00001312  2601                     299      move.l d1, d3
00001314  0683 00000010            300      add.l #BULLET_WIDTH, d3
0000131A  4E4F                     301      trap #15
0000131C                           302      
0000131C                           303  
0000131C  4CDF 7FFF                304      movem.l (sp)+, ALL_REG
00001320  4E75                     305      rts
00001322                           306  
00001322                           307  deleteBullet:
00001322                           308      *All we have to do to 'delete' the bullet is decrease the value of numBullets
00001322                           309      *This effectively stops the bullet from being updated/printed
00001322  47F8 114E                310      lea numBullets, a3
00001326  5393                     311      subi.l #1, (a3)
00001328                           312      ;move.l #1, (a2)
00001328                           313      
00001328  60A8                     314      bra returnFromDelete
0000132A                           315  
0000132A= 0000000A                 316  bulletVelocity dc.l 10
0000132E                           317  
0000132E                           318  
0000132E                           319  
0000132E                           320  
0000132E                           321  
0000132E                           322  
0000132E                           323  
0000132E                           324  
0000132E                           325  
0000132E                           326  
0000132E                           327  
0000132E                           328      
0000132E                           329  
0000132E                           330  
0000132E                           331  
0000132E                           332  
0000132E                           333  
0000132E                           334  
0000132E                           335  
0000132E                           336  
0000132E                           337  
0000132E                           338  
0000132E                           339  -------------------- end include --------------------
0000132E                           340      INCLUDE "Alien.x68"
0000132E                           341  
0000132E  =00000008                342  GET_TIME_COMMAND equ 8
0000132E  =00000050                343  SET_PEN_COLOR_COMMAND equ 80
0000132E  =00000051                344  FILL_COLOR_COMMAND equ 81
0000132E  =00000053                345  GET_PIXEL_COLOR_COMMAND equ 83
0000132E  =00000057                346  DRAW_RECTANGLE_COMMAND equ 87
0000132E                           347  
0000132E  =0000000E                348  ALIEN_WIDTH equ 14
0000132E  =0000000E                349  ALIEN_HEIGHT equ 14
0000132E  =00002B7A                350  ALIEN_TOP_Y_POSITION equ 11130
0000132E  =00000064                351  ALIEN_START_X_POSITION equ 100
0000132E  =00000005                352  ALIEN_RIGHT_VELOCITY equ 5
0000132E  =FFFFFFFB                353  ALIEN_LEFT_VELOCITY equ -5
0000132E  =00000004                354  ALIEN_DOWN_ACCELERATION equ 4
0000132E  =000001F4                355  BOTTOM_SIDE_OF_SCREEN equ 500
0000132E  =0000000F                356  SUM_OF_RADII equ 15
0000132E  =000000E1                357  SUM_OF_RADII_SQUARED equ 225
0000132E                           358  
0000132E  =000000FF                359  RED equ $000000FF
0000132E  =00FFFFFF                360  RANDOM_MASK equ $FFFFFF
0000132E                           361  
0000132E                           362  initAlien:
0000132E                           363      *Get a random spawn point
0000132E  4EB9 00001516            364      jsr generateRandomSpawnPoint
00001334                           365      
00001334                           366      *Init Y coordinate
00001334  243C 00002B7A            367      move.l #ALIEN_TOP_Y_POSITION, d2
0000133A                           368      
0000133A                           369      *Store the init values of the Alien starting position in it's table
0000133A  41F9 00001536            370      lea alienTableX1, a0
00001340  43F9 000015D6            371      lea alienTableY1, a1
00001346  45F9 00001586            372      lea alienTableX2, a2
0000134C  47F9 00001626            373      lea alienTableY2, a3
00001352  2087                     374      move.l d7, (a0)
00001354  2487                     375      move.l d7, (a2)
00001356  2282                     376      move.l d2, (a1)
00001358  2682                     377      move.l d2, (a3)
0000135A  0692 0000000E            378      addi.l #ALIEN_WIDTH, (a2)
00001360  0693 0000000E            379      addi.l #ALIEN_HEIGHT, (a3)
00001366                           380      
00001366  4E75                     381      rts
00001368                           382   
00001368                           383  updateAlien:
00001368  48E7 FFFE                384      movem.l ALL_REG, -(sp)
0000136C                           385      
0000136C                           386      ;Get our alien coordinate table ready, and move them to registers
0000136C  41F9 00001536            387      lea alienTableX1, a0
00001372  43F9 000015D6            388      lea alienTableY1, a1
00001378  45F9 00001586            389      lea alienTableX2, a2
0000137E  47F9 00001626            390      lea alienTableY2, a3
00001384  4DF9 00001532            391      lea alienDownVelocity, a6
0000138A  2210                     392      move.l (a0), d1
0000138C  2411                     393      move.l (a1), d2
0000138E  2612                     394      move.l (a2), d3
00001390  2813                     395      move.l (a3), d4
00001392                           396      
00001392                           397      *Add velocity to current Y coordinate to update position
00001392  D496                     398      add.l (a6), d2
00001394                           399      
00001394                           400      *Compare to see if Alien reached bottom of the screen or not
00001394  0C82 0001E600            401      cmpi.l #(BOTTOM_SIDE_OF_SCREEN-ALIEN_HEIGHT)<<8, d2
0000139A  6C00 000A                402      bge deleteAlien
0000139E                           403      
0000139E                           404      *If reached here, Alien didn't reach bottom, so store coordinates for next iteration of loop
0000139E                           405      ;move.l d1, (a0)
0000139E  2282                     406      move.l d2, (a1)
000013A0  4CDF 7FFF                407      movem.l (sp)+, ALL_REG
000013A4  4E75                     408      rts
000013A6                           409  
000013A6                           410  deleteAlien:
000013A6                           411      *If we get here, the alien made it to the bottom of screen, so set Lose flag for the gameLoop
000013A6                           412      ;lea LoseFlag, a0
000013A6                           413      ;addi.l #1, (a0) 
000013A6                           414      
000013A6  4EB8 132E                415      jsr initAlien
000013AA  4CDF 7FFF                416      movem.l (sp)+, ALL_REG
000013AE  4E75                     417      rts
000013B0                           418     
000013B0                           419  drawAlien:
000013B0  48E7 FFFE                420      movem.l ALL_REG, -(sp)
000013B4                           421      
000013B4  223C 000000FF            422      move.l #RED, d1
000013BA  103C 0050                423      move.b #SET_PEN_COLOR_COMMAND, d0
000013BE  4E4F                     424      trap #15
000013C0  103C 0051                425      move.b #SET_FILL_COLOR_COMMAND, d0
000013C4  4E4F                     426      trap #15
000013C6                           427      
000013C6                           428      *Get the current values from the Alien coordinate table, move to registers,
000013C6                           429      *shift accordingly since we're using fixed point math, and draw it to the screen
000013C6  41F9 00001536            430      lea alienTableX1, a0
000013CC  43F9 000015D6            431      lea alienTableY1, a1
000013D2  45F9 00001586            432      lea alienTableX2, a2
000013D8  47F9 00001626            433      lea alienTableY2, a3
000013DE  103C 0058                434      move.b #DRAW_CIRCLE_COMMAND, d0
000013E2  2210                     435      move.l (a0), d1
000013E4  2411                     436      move.l (a1), d2
000013E6  E082                     437      asr.l #8, d2
000013E8  2601                     438      move.l d1, d3
000013EA  2802                     439      move.l d2, d4
000013EC  0684 0000000E            440      add.l #ALIEN_HEIGHT, d4
000013F2  0683 0000000E            441      add.l #ALIEN_WIDTH, d3
000013F8  4E4F                     442      trap #15
000013FA                           443      
000013FA  2081                     444      move.l d1, (a0)
000013FC  4CDF 7FFF                445      movem.l (sp)+, ALL_REG
00001400  4E75                     446      rts
00001402                           447  
00001402                           448  detectCollision:
00001402  48E7 FFFE                449      movem.l ALL_REG, -(sp)
00001406                           450      
00001406                           451      *If the number of Bullets is currently 0, we don't have any collision to detect, so just skip this call
00001406  43F8 114E                452      lea numBullets, a1
0000140A  2211                     453      move.l (a1), d1
0000140C  0C81 00000000            454      cmpi.l #0, d1
00001412  6700 003E                455      beq checkBullet2    
00001416                           456      
00001416                           457      *Get the current X/Y position of the Bullet and the Alien, and put them into reg
00001416  41F8 1152                458      lea bulletTableX1, a0
0000141A  43F8 11F2                459      lea bulletTableY1, a1
0000141E  45F9 00001536            460      lea alienTableX1, a2
00001424  47F9 000015D6            461      lea alienTableY1, a3
0000142A                           462      
0000142A                           463      *The given coordinates are at the Top-Left of the given shape.
0000142A                           464      *We need the coordinates at the CENTER of the shape to detect collision,
0000142A                           465      *so simply add half of the width to the X, and half of the height to the Y to get the Center coordinates
0000142A  2210                     466      move.l (a0), d1
0000142C  5081                     467      add.l #(BULLET_WIDTH/2), d1
0000142E  2411                     468      move.l (a1), d2
00001430  E082                     469      asr.l #8, d2
00001432  5082                     470      add.l #(BULLET_HEIGHT/2), d2
00001434                           471       
00001434                           472      *Getting center of Alien 
00001434  2612                     473      move.l (a2), d3
00001436  5E83                     474      add.l #(ALIEN_WIDTH/2), d3
00001438  2813                     475      move.l (a3), d4
0000143A  E084                     476      asr.l #8, d4
0000143C  5E84                     477      add.l #(ALIEN_HEIGHT/2), d4
0000143E                           478      
0000143E                           479      *To detect collision between two circles, we must compare the distance between their centers
0000143E                           480      *to the sum of their radii. If this distacnce is smaller than the sum of their radii, then the 2 circles are colliding.
0000143E                           481      *The formula we need is: sqrt((x1-x2)^2 + (y1-y2)^2) <= SUM_OF_RADII
0000143E  9681                     482      sub.l d1, d3
00001440  C7C3                     483      muls d3, d3
00001442  9882                     484      sub.l d2, d4
00001444  C9C4                     485      muls d4, d4
00001446  D684                     486      add.l d4, d3
00001448                           487      
00001448                           488      *Since hard to get the sqaure root, just square both sides to get easier calculation
00001448                           489      *New formula is: (x1-x2)^2 + (y1-y2)^2 <= SUM_OF_RADII_SQUARED
00001448                           490      *If we have a collision, then delete the Alien
00001448  0C83 000000E1            491      cmpi.l #SUM_OF_RADII_SQUARED, d3
0000144E  6F00 005A                492      ble delete
00001452                           493  
00001452                           494  checkBullet2:    
00001452  43F9 00001A30            495      lea numBullets2, a1
00001458  2211                     496      move.l (a1), d1
0000145A  0C81 00000000            497      cmpi.l #0, d1
00001460  6700 00AE                498      beq skip
00001464                           499      
00001464                           500      *If we reach here, time to detect collision for Player 2!
00001464  41F9 00001A34            501      lea bulletTable2X1, a0
0000146A  43F9 00001AD4            502      lea bulletTable2Y1, a1
00001470  45F9 00001536            503      lea alienTableX1, a2
00001476  47F9 000015D6            504      lea alienTableY1, a3
0000147C                           505      
0000147C                           506      *Get the center of Bullet 2
0000147C  2210                     507      move.l (a0), d1
0000147E  5081                     508      add.l #(BULLET_WIDTH/2), d1
00001480  2411                     509      move.l (a1), d2
00001482  E082                     510      asr.l #8, d2
00001484  5082                     511      add.l #(BULLET_HEIGHT/2), d2
00001486                           512      
00001486                           513      *Now get center of alien again
00001486  2612                     514      move.l (a2), d3
00001488  5E83                     515      add.l #(ALIEN_WIDTH/2), d3
0000148A  2813                     516      move.l (a3), d4
0000148C  E084                     517      asr.l #8, d4
0000148E  5E84                     518      add.l #(ALIEN_HEIGHT/2), d4
00001490                           519      
00001490                           520      *To detect collision between two circles, we must compare the distance between their centers
00001490                           521      *to the sum of their radii. If this distacnce is smaller than the sum of their radii, then the 2 circles are colliding.
00001490                           522      *The formula we need is: sqrt((x1-x2)^2 + (y1-y2)^2) <= SUM_OF_RADII
00001490  9681                     523      sub.l d1, d3
00001492  C7C3                     524      muls d3, d3
00001494  9882                     525      sub.l d2, d4
00001496  C9C4                     526      muls d4, d4
00001498  D684                     527      add.l d4, d3
0000149A                           528      
0000149A                           529      *Since hard to get the sqaure root, just square both sides to get easier calculation
0000149A                           530      *New formula is: (x1-x2)^2 + (y1-y2)^2 <= SUM_OF_RADII_SQUARED
0000149A                           531      *If we have a collision, then delete the Alien
0000149A  0C83 000000E1            532      cmpi.l #SUM_OF_RADII_SQUARED, d3
000014A0  6F00 003A                533      ble delete2
000014A4                           534      
000014A4  4CDF 7FFF                535      movem.l (sp)+, ALL_REG
000014A8  4E75                     536      rts
000014AA                           537      
000014AA                           538  delete:
000014AA                           539      ;Delete Bullet
000014AA  41F8 114E                540      lea numBullets, a0
000014AE  5390                     541      subi.l #1, (a0)
000014B0                           542      
000014B0                           543      ;Increase velocity of alien on next spawn
000014B0  41F9 00001532            544      lea alienDownVelocity, a0
000014B6  5890                     545      addi.l #ALIEN_DOWN_ACCELERATION, (a0)
000014B8                           546      
000014B8                           547      ;Increase score
000014B8  41F9 00001676            548      lea player1Score, a0
000014BE  5290                     549      addi.l #1, (a0)
000014C0                           550      
000014C0                           551      ;Respawn the Alien
000014C0  4EB8 132E                552      jsr initAlien
000014C4                           553      
000014C4  4CDF 7FFF                554      movem.l (sp)+, ALL_REG
000014C8                           555      
000014C8                           556      *At the same time that we delete the bullet & and alien,
000014C8                           557      *we need to draw the bitmap bg behind the score, then update the scores
000014C8  4EB9 00001D64            558      jsr drawBitmap
000014CE  4EB9 000016C8            559      jsr updateScore
000014D4  4EB9 00001C10            560      jsr updateScore2
000014DA  4E75                     561      rts
000014DC                           562  
000014DC                           563  delete2:
000014DC  41F9 00001A30            564      lea numBullets2, a0
000014E2  5390                     565      subi.l #1, (a0)
000014E4                           566      
000014E4  41F9 00001532            567      lea alienDownVelocity, a0
000014EA  5290                     568      addi.l #1, (a0)
000014EC                           569      
000014EC  41F9 0000167A            570      lea player2Score, a0
000014F2  5290                     571      addi.l #1, (a0)
000014F4                           572      
000014F4  4EB8 132E                573      jsr initAlien
000014F8                           574      
000014F8  4CDF 7FFF                575      movem.l (sp)+, ALL_REG
000014FC                           576      
000014FC                           577      *At the same time that we delete the bullet & and alien,
000014FC                           578      *we need to draw the bitmap bg behind the score, then update the scores
000014FC  4EB9 00001D64            579      jsr drawBitmap
00001502  4EB9 000016C8            580      jsr updateScore
00001508  4EB9 00001C10            581      jsr updateScore2
0000150E  4E75                     582      rts
00001510                           583      
00001510                           584  skip:
00001510  4CDF 7FFF                585      movem.l (sp)+, ALL_REG,
00001514  4E75                     586      rts
00001516                           587  
00001516                           588  generateRandomSpawnPoint:
00001516  4247                     589      clr d7
00001518                           590      
00001518                           591      *Get current time for seed
00001518  103C 0008                592      move.b #GET_TIME_COMMAND, d0
0000151C  4E4F                     593      trap #15
0000151E                           594      
0000151E                           595      *Take the seed, and it with a mask to get a random value, and divide that value by 600 (number determined by size of the screen)
0000151E  0281 00FFFFFF            596      andi.l #$FFFFFF, d1
00001524  82FC 021C                597      divu #540, d1
00001528                           598      *Swaping gives us the remainder, and since we divided by 600, we will get a remainder from 0-599
00001528                           599      *Thus, we effectively get a random number generator from the range of 0-599, which is then moved to be used as the init position of an Alien on spawn
00001528  4841                     600      swap d1
0000152A  0641 003C                601      addi.w #60, d1
0000152E  3E01                     602      move.w d1, d7
00001530                           603      
00001530  4E75                     604      rts
00001532                           605      
00001532= 00000007                 606  alienDownVelocity dc.l 7    
00001536                           607  
00001536                           608  alienTableX1: ds.l 20
00001586                           609  alienTableX2: ds.l 20
000015D6                           610  alienTableY1: ds.l 20
00001626                           611  alienTableY2: ds.l 20
00001676                           612  
00001676= 00000000                 613  player1Score dc.l 0
0000167A                           614  
0000167A= 00000000                 615  player2Score dc.l 0
0000167E                           616  
0000167E= 00000000                 617  LoseFlag dc.l 0
00001682                           618  
00001682                           619  
00001682                           620  
00001682                           621  
00001682                           622  
00001682                           623  
00001682                           624  
00001682                           625  
00001682                           626  
00001682                           627  
00001682                           628  
00001682                           629  
00001682                           630  
00001682                           631  
00001682                           632  -------------------- end include --------------------
00001682                           633      INCLUDE "LED.x68"
00001682                           634  
00001682                           635  ALL_DATA_REG reg d0-d7
00001682  =0000000E                636  PRINT_TEXT_COMMAND equ 14
00001682  =00000050                637  SET_PEN_COLOR_COMMAND equ 80
00001682  =00000051                638  SET_FILL_COLOR_COMMAND equ 81
00001682  =00000057                639  DRAW_RECTANGLE_COMMAND equ 87
00001682                           640  
00001682  =00000014                641  LEFT_X_COORDINATE equ 20
00001682  =0000001E                642  RIGHT_X_COORDINATE equ 30
00001682  =0000001E                643  TOP_Y_COORDINATE equ 30
00001682  =00000028                644  MIDDLE_Y_COORDINATE equ 40
00001682  =00000032                645  BOTTOM_Y_COORDINATE equ 50
00001682  =00000006                646  COORDINATE_OFFSET equ 6
00001682  =0000000F                647  PRINT_OFFSET equ 15
00001682  =0000000A                648  WIN_SCORE equ 10
00001682                           649  
00001682  =00000039                650  TEST_NUMBER equ 57   
00001682                           651   
00001682  =00FFFFFF                652  WHITE equ $00FFFFFF   
00001682                           653  
00001682                           654  initLED:
00001682  48E7 FFFE                655      movem.l ALL_REG, -(sp)
00001686                           656      
00001686  41F9 00001808            657      lea coordinateTableOffset, a0
0000168C  43F9 00001809            658      lea printOffset, a1
00001692  45F9 0000180A            659      lea printFlag, a2
00001698  47F8 1676                660      lea player1Score, a3
0000169C  49F8 167A                661      lea player2Score, a4
000016A0  4BF8 1532                662      lea alienDownVelocity, a5
000016A4                           663      
000016A4  10BC 0006                664      move.b #COORDINATE_OFFSET, (a0)
000016A8  12BC 0000                665      move.b #0, (a1)
000016AC  14BC 0000                666      move.b #0, (a2)
000016B0  26BC 00000000            667      move.l #0, (a3)
000016B6  28BC 00000000            668      move.l #0, (a4)
000016BC  2ABC 00000007            669      move.l #7, (a5)
000016C2                           670      
000016C2  4CDF 7FFF                671      movem.l (sp)+, ALL_REG
000016C6  4E75                     672      rts
000016C8                           673  updateScore:
000016C8  48E7 FFFE                674      movem.l ALL_REG, -(sp)
000016CC                           675    
000016CC  4283                     676      clr.l d3
000016CE  4284                     677      clr.l d4
000016D0                           678      
000016D0                           679      *Load the current score that we need to draw, as well as the tables that hold the 
000016D0                           680      *bitmask for our 7 segment LED, and the coordinates for each of the segments
000016D0  41F8 1676                681      lea player1Score, a0
000016D4  2A10                     682      move.l (a0), d5
000016D6  41F9 000017E2            683      lea sevenSegmentTable, a0
000016DC  43F9 00001808            684      lea coordinateTableOffset, a1
000016E2  45F9 000017EC            685      lea coordinateTableX1, a2
000016E8  47F9 000017FA            686      lea coordinateTableY1, a3
000016EE  49F9 000017F3            687      lea coordinateTableX2, a4
000016F4  4BF9 00001801            688      lea coordinateTableY2, a5
000016FA  4DF9 00001809            689      lea printOffset, a6
00001700                           690      
00001700                           691  ;d0 - trap codes
00001700                           692  ;d5 - number to print
00001700                           693  ;d6 - single digit to print
00001700                           694  ;d3 - value of segment to print
00001700                           695  ;d4 - AND register  
00001700                           696  readDigit:
00001700                           697      *Set value of the coordinate offset used to index segment coordinate table
00001700  12BC 0006                698      move.b #COORDINATE_OFFSET, (a1)
00001704                           699      
00001704                           700      *Divide the current score by 10, then swap to get the remainder
00001704                           701      *This remainder will give us the one's digit we need to draw
00001704  8AFC 000A                702      divu #10, d5
00001708  4845                     703      swap d5
0000170A  3C05                     704      move.w d5, d6
0000170C                           705      
0000170C                           706      *Using the digit itself as an offset, go into the segment table to find out which number needs to be drawn
0000170C  1630 6000                707      move.b (a0, d6), d3
00001710  2803                     708      move.l d3, d4
00001712                           709  
00001712                           710  loop:    
00001712                           711      *And 1 to see if the lowest bit is set, to see which segment needs to be drawn
00001712                           712      *If the bit is set to 0, segment must not be drawn, and we must shift down one
00001712  0284 00000001            713      andi.l #1, d4
00001718  6700 0038                714      beq shift
0000171C                           715    
0000171C                           716  drawSegment:
0000171C  48E7 FF00                717      movem.l ALL_DATA_REG, -(sp)
00001720                           718      
00001720  7050                     719      move.l #SET_PEN_COLOR_COMMAND, d0
00001722  223C 00FFFFFF            720      move.l #WHITE, d1
00001728  4E4F                     721      trap #15
0000172A                           722      
0000172A  4240                     723      clr d0
0000172C  4281                     724      clr.l d1
0000172E  4282                     725      clr.l d2
00001730  4283                     726      clr.l d3
00001732  4284                     727      clr.l d4
00001734                           728      
00001734                           729      *If we reach here, we know which digit to draw, which segment to draw, so get the coordinates of each segment to draw
00001734                           730      *from the Segment coordinate table
00001734  1011                     731      move.b (a1), d0
00001736  1232 0000                732      move.b (a2, d0), d1
0000173A  D216                     733      add.b (a6), d1
0000173C  1433 0000                734      move.b (a3, d0), d2
00001740  1634 0000                735      move.b (a4, d0), d3
00001744  D616                     736      add.b (a6), d3
00001746  1835 0000                737      move.b (a5, d0), d4
0000174A                           738      
0000174A  7057                     739      move.l #DRAW_RECTANGLE_COMMAND, d0
0000174C  4E4F                     740      trap #15
0000174E                           741      
0000174E  4CDF 00FF                742      movem.l (sp)+, ALL_DATA_REG
00001752                           743      
00001752                           744  shift:
00001752                           745      *Shift bitmask by 1 since we didn't draw last segment
00001752  E24B                     746      lsr #1, d3
00001754                           747      
00001754                           748      *Check if the value after shift is 0. If so, we're done this digit, so move onto the next one.
00001754  0C83 00000000            749      cmpi.l #0, d3
0000175A  6700 0008                750      beq upperSwap
0000175E                           751      
0000175E                           752      *If reach here, we still have segments left to draw
0000175E                           753      *Move the current segment back into the reg, and go back to the drawing loop 
0000175E  2803                     754      move.l d3, d4
00001760  5311                     755      subi.b #1, (a1)
00001762  60AE                     756      bra loop  
00001764                           757   
00001764                           758  upperSwap:
00001764                           759      *Load the print flag, add 1, and check if the value is 2
00001764                           760      *If so, we printed all digits, so stop printing the score
00001764  4DF9 0000180A            761      lea printFlag, a6
0000176A  5216                     762      addi.b #1, (a6)
0000176C  0C16 0002                763      cmpi.b #2, (a6)
00001770  6700 001C                764      beq stopPrinting
00001774                           765      
00001774                           766      *If we reach here, reset the coordinate offset,
00001774                           767      *and swap the value in d5, since before we had the ones digit, now we need the tens digit
00001774  12BC 0006                768      move.b #COORDINATE_OFFSET, (a1)
00001778  4845                     769      swap d5
0000177A  3C05                     770      move.w d5, d6
0000177C                           771      
0000177C                           772      *Set the offset for printing the tens digit, since the tens digit needs to be offset to the left of the ones digit
0000177C  4DF9 00001809            773      lea printOffset, a6
00001782  0416 000F                774      subi.b #PRINT_OFFSET, (a6)
00001786                           775         
00001786  1630 6000                776      move.b (a0, d6), d3
0000178A  2803                     777      move.l d3, d4
0000178C  6084                     778      bra loop
0000178E                           779   
0000178E                           780  stopPrinting:
0000178E                           781      *Reset the print offset, and return 
0000178E  1CBC 0000                782      move.b #0, (a6)
00001792  4DF9 00001809            783      lea printOffset, a6
00001798  1CBC 0000                784      move.b #0, (a6)
0000179C                           785      
0000179C  4CDF 7FFF                786      movem.l (sp)+,ALL_REG
000017A0  4E75                     787      rts
000017A2                           788  
000017A2                           789  checkP1WinScore:
000017A2  48E7 FFFE                790      movem.l ALL_REG, -(sp)
000017A6                           791      
000017A6  41F8 1676                792      lea player1Score, a0
000017AA  0C90 0000000A            793      cmpi.l #WIN_SCORE, (a0)
000017B0                           794      
000017B0  4CDF 7FFF                795      movem.l (sp)+, ALL_REG 
000017B4  4E75                     796      rts
000017B6                           797  
000017B6                           798  checkP2WinScore:
000017B6  48E7 FFFE                799      movem.l ALL_REG, -(sp)
000017BA                           800      
000017BA  41F8 167A                801      lea player2Score, a0
000017BE  0C90 0000000A            802      cmpi.l #WIN_SCORE, (a0)
000017C4                           803      
000017C4  4CDF 7FFF                804      movem.l (sp)+, ALL_REG
000017C8  4E75                     805      rts
000017CA                           806     
000017CA                           807  printP1ScreenWin:
000017CA                           808      
000017CA  43F9 0000180B            809      lea player1String, a1
000017D0  700E                     810      move.l #PRINT_TEXT_COMMAND, d0
000017D2  4E4F                     811      trap #15
000017D4                           812      
000017D4  4E75                     813      rts
000017D6                           814         
000017D6                           815  printP2ScreenWin:
000017D6  43F9 00001831            816      lea player2String, a1
000017DC  700E                     817      move.l #PRINT_TEXT_COMMAND, d0
000017DE  4E4F                     818      trap #15
000017E0                           819      
000017E0  4E75                     820      rts
000017E2                           821      
000017E2= 7E                       822  sevenSegmentTable:  dc.b $7E    ;0 = ABCDEF = 7E
000017E3= 30                       823                      dc.b $30    ;1 = BC = 30
000017E4= 6D                       824                      dc.b $6D    ;2 = ABDEG = 6D
000017E5= 79                       825                      dc.b $79    ;3 = ABCDG = 79
000017E6= 33                       826                      dc.b $33    ;4 = BCFG = 33
000017E7= 5B                       827                      dc.b $5B    ;5 = ACDFG = 5B
000017E8= 5F                       828                      dc.b $5F    ;6 = ACDEFG = 5F
000017E9= 70                       829                      dc.b $70    ;7 = ABC = 70
000017EA= 7F                       830                      dc.b $7F    ;8 = ABCDEFG = 7F
000017EB= 7B                       831                      dc.b $7B    ;9 = ABCDFG = 7B
000017EC                           832      
000017EC                           833  
000017EC= 14                       834  coordinateTableX1:  dc.b LEFT_X_COORDINATE    ;A
000017ED= 1E                       835                      dc.b RIGHT_X_COORDINATE   ;B
000017EE= 1E                       836                      dc.b RIGHT_X_COORDINATE   ;C
000017EF= 14                       837                      dc.b LEFT_X_COORDINATE    ;D
000017F0= 14                       838                      dc.b LEFT_X_COORDINATE    ;E
000017F1= 14                       839                      dc.b LEFT_X_COORDINATE    ;F
000017F2= 14                       840                      dc.b LEFT_X_COORDINATE    ;G 
000017F3                           841     
000017F3                           842  
000017F3= 1E                       843  coordinateTableX2:  dc.b RIGHT_X_COORDINATE   ;A
000017F4= 1E                       844                      dc.b RIGHT_X_COORDINATE   ;B
000017F5= 1E                       845                      dc.b RIGHT_X_COORDINATE   ;C
000017F6= 1E                       846                      dc.b RIGHT_X_COORDINATE   ;D
000017F7= 14                       847                      dc.b LEFT_X_COORDINATE    ;E
000017F8= 14                       848                      dc.b LEFT_X_COORDINATE    ;F
000017F9= 1E                       849                      dc.b RIGHT_X_COORDINATE   ;G
000017FA                           850  
000017FA= 1E                       851  coordinateTableY1:  dc.b TOP_Y_COORDINATE     ;A
000017FB= 1E                       852                      dc.b TOP_Y_COORDINATE     ;B
000017FC= 28                       853                      dc.b MIDDLE_Y_COORDINATE  ;C
000017FD= 32                       854                      dc.b BOTTOM_Y_COORDINATE  ;D
000017FE= 32                       855                      dc.b BOTTOM_Y_COORDINATE  ;E
000017FF= 28                       856                      dc.b MIDDLE_Y_COORDINATE  ;F
00001800= 28                       857                      dc.b MIDDLE_Y_COORDINATE  ;G
00001801                           858  
00001801= 1E                       859  coordinateTableY2:  dc.b TOP_Y_COORDINATE     ;A
00001802= 28                       860                      dc.b MIDDLE_Y_COORDINATE  ;B
00001803= 32                       861                      dc.b BOTTOM_Y_COORDINATE  ;C
00001804= 32                       862                      dc.b BOTTOM_Y_COORDINATE  ;D
00001805= 28                       863                      dc.b MIDDLE_Y_COORDINATE  ;E
00001806= 1E                       864                      dc.b TOP_Y_COORDINATE     ;F
00001807= 28                       865                      dc.b MIDDLE_Y_COORDINATE  ;G  
00001808                           866  
00001808= 06                       867  coordinateTableOffset dc.b 6
00001809                           868  
00001809= 00                       869  printOffset dc.b 0
0000180A                           870  
0000180A= 00                       871  printFlag dc.b 0
0000180B                           872  
0000180B= 50 6C 61 79 65 72 ...    873  player1String dc.b 'Player 1 Wins! Press R to play again.',0
00001831                           874  
00001831= 50 6C 61 79 65 72 ...    875  player2String dc.b 'Player 2 Wins! Press R to play again',0
00001856                           876  
00001856                           877  
00001856= 00000000                 878  morePadding dc.l 0
0000185A                           879  
0000185A                           880  
0000185A                           881  
0000185A                           882  
0000185A                           883  
0000185A                           884  
0000185A                           885  
0000185A                           886  
0000185A                           887  
0000185A                           888  
0000185A                           889  
0000185A                           890  
0000185A                           891  
0000185A                           892  -------------------- end include --------------------
0000185A                           893      INCLUDE "Player2.x68"
0000185A                           894  
0000185A  =00000050                895  SET_PEN_COLOR_COMMAND equ 80
0000185A  =00000051                896  SET_FILL_COLOR_COMMAND equ 81
0000185A  =00000057                897  DRAW_RECTANGLE_COMMAND equ 87
0000185A  =00000013                898  GET_USER_INPUT_COMMAND equ 19
0000185A                           899  
0000185A  =00000014                900  PLAYER_WIDTH equ 20
0000185A  =00000014                901  PLAYER_HEIGHT equ 20
0000185A  =0001B350                902  PLAYER_TOP_Y_POSITION equ 111440
0000185A  =0001B224                903  PLAYER2_STARTING_X_POSITION equ 111140
0000185A  =00000023                904  PLAYER_RIGHT_VELOCITY equ 35
0000185A  =FFFFFFDD                905  PLAYER_LEFT_VELOCITY equ -35
0000185A  =00000280                906  RIGHT_SIDE_OF_SCREEN equ 640
0000185A                           907  
0000185A  =00000025                908  LEFT_ARROW equ $25
0000185A  =00000027                909  RIGHT_ARROW equ $27
0000185A  =0000002D                910  ZERO_KEYPAD equ $2D
0000185A                           911  
0000185A  =00008000                912  GREEN equ $00008000
0000185A                           913  
0000185A                           914  initPlayer2
0000185A  41F9 00001A20            915      lea player2X1, a0
00001860  43F9 00001A28            916      lea player2Y1, a1
00001866  45F9 00001A24            917      lea player2X2, a2
0000186C  47F9 00001A2C            918      lea player2Y2, a3
00001872                           919      
00001872                           920      *init x position
00001872  20BC 0001B224            921      move.l #PLAYER2_STARTING_X_POSITION, (a0)
00001878  24BC 0001B224            922      move.l #PLAYER2_STARTING_X_POSITION, (a2)
0000187E  0692 00000014            923      add.l #PLAYER_WIDTH, (a2)
00001884                           924      
00001884                           925      *set ball y position and height
00001884  22BC 01B35000            926      move.l #PLAYER_TOP_Y_POSITION<<8, (a1)
0000188A  26BC 01B35000            927      move.l #PLAYER_TOP_Y_POSITION<<8, (a3)
00001890  0693 00000014            928      add.l #PLAYER_HEIGHT, (a3)
00001896                           929      
00001896                           930      *init the number of bullets to 0 since we don't have any yet
00001896  49F9 00001A30            931      lea numBullets2, a4
0000189C  28BC 00000000            932      move.l #0, (a4)
000018A2                           933  
000018A2  4E75                     934      rts
000018A4                           935  
000018A4                           936  updatePlayer2: 
000018A4  48E7 FFFE                937      movem.l ALL_REG, -(sp)
000018A8                           938      
000018A8  4281                     939      clr.l d1
000018AA  4282                     940      clr.l d2
000018AC  4283                     941      clr.l d3
000018AE  4284                     942      clr.l d4
000018B0                           943      
000018B0  41F9 00001A20            944      lea player2X1, a0
000018B6  43F9 00001A28            945      lea player2Y1, a1
000018BC  45F9 00001A24            946      lea player2X2, a2
000018C2  47F9 00001A2C            947      lea player2Y2, a3
000018C8  2E10                     948      move.l (a0), d7
000018CA  2411                     949      move.l (a1), d2
000018CC  2612                     950      move.l (a2), d3
000018CE  2813                     951      move.l (a3), d4
000018D0                           952      
000018D0                           953      *If the player presses the '6' key, call the function to move player object right
000018D0  7227                     954      move.l #$27, d1
000018D2  103C 0013                955      move.b #GET_USER_INPUT_COMMAND, d0
000018D6  4E4F                     956      trap #15
000018D8  2A01                     957      move.l d1, d5
000018DA  0285 000000FF            958      andi.l #$FF, d5
000018E0  6600 0044                959      bne rightPressed
000018E4                           960      
000018E4                           961      *If the player presses the '4' key, call the function to move player object left
000018E4  7225                     962      move.l #$25, d1
000018E6  103C 0013                963      move.b #GET_USER_INPUT_COMMAND, d0
000018EA  4E4F                     964      trap #15
000018EC  2A01                     965      move.l d1, d5
000018EE  0285 000000FF            966      andi.l #$FF, d5
000018F4  6600 0046                967      bne leftPressed
000018F8                           968      
000018F8                           969      *Check to see if space was already pressed the previous frame before. If it was, don't detect input from space this iteration of the update
000018F8                           970      *This is because when a button is pressed, Easy68K detects the input for multiple frames, so the bullets were getting spammed too much
000018F8                           971      *This gets rid of the spam issue, and forces the user to shoot 1 bullet at a given time
000018F8  4241                     972      clr d1
000018FA  43F9 00001A30            973      lea numBullets2, a1
00001900  2211                     974      move.l (a1), d1
00001902  0C81 00000001            975      cmpi.l #1, d1
00001908  6700 00B4                976      beq return2
0000190C                           977     
0000190C                           978      *If the player presses 'Ctrl', call function to shoot bullet
0000190C  7211                     979      move.l #$11, d1
0000190E  103C 0013                980      move.b #GET_USER_INPUT_COMMAND, d0
00001912  4E4F                     981      trap #15
00001914  2A01                     982      move.l d1, d5
00001916  0285 000000FF            983      andi.l #$FF, d5
0000191C  6600 0034                984      bne firePressed
00001920                           985      
00001920  4CDF 7FFF                986      movem.l (sp)+, ALL_REG
00001924  4E75                     987      rts
00001926                           988      
00001926                           989  rightPressed:
00001926                           990      *Add right velocity to the current player position to get the new position
00001926  7C23                     991      move.l #PLAYER_RIGHT_VELOCITY, d6
00001928  DE86                     992      add.l d6, d7
0000192A                           993      
0000192A                           994      *Compare the new position to our screen bounds. If it's too big, we have to undo the last addition we made
0000192A  0C87 00026C00            995      cmpi.l #(RIGHT_SIDE_OF_SCREEN-PLAYER_WIDTH)<<8, d7
00001930  6C00 0070                996      bge subtractOne2
00001934                           997      
00001934  2087                     998      move.l d7, (a0)
00001936  4CDF 7FFF                999      movem.l (sp)+, ALL_REG
0000193A  4E75                    1000      rts
0000193C                          1001  
0000193C                          1002  leftPressed:
0000193C                          1003      *Add left velocity to current player position to get new position
0000193C  7CDD                    1004      move.l #PLAYER_LEFT_VELOCITY, d6
0000193E  DE86                    1005      add.l d6, d7
00001940                          1006      
00001940                          1007      *Compare new position to screen bounds. If it's too small, undo the last addition we made
00001940  0C87 00000028           1008      cmpi.l #PLAYER_STARTING_X_POSITION, d7
00001946  6F00 0068               1009      ble addOne2
0000194A                          1010      
0000194A  2087                    1011      move.l d7, (a0)
0000194C  4CDF 7FFF               1012      movem.l (sp)+, ALL_REG
00001950  4E75                    1013      rts
00001952                          1014  
00001952                          1015  firePressed:
00001952  2087                    1016      move.l d7, (a0)
00001954                          1017      
00001954                          1018      *Load the bullet's coordinate table, the number of bullets, and the bulletActive flag
00001954  43F9 00001A34           1019      lea bulletTable2X1, a1
0000195A  45F9 00001AD4           1020      lea bulletTable2Y1, a2
00001960  47F9 00001A84           1021      lea bulletTable2X2, a3
00001966  49F9 00001B24           1022      lea bulletTable2Y2, a4
0000196C  4BF9 00001A30           1023      lea numBullets2, a5
00001972  4DF9 00001B74           1024      lea bullet2Active, a6
00001978                          1025      
00001978                          1026      ;Shift to get the X coordinate of the player, which is used to init the X coordinate of the bullet when fired
00001978  2207                    1027      move.l d7, d1
0000197A  E081                    1028      asr.l #8, d1
0000197C  2601                    1029      move.l d1, d3
0000197E  0683 00000014           1030      add.l #PLAYER_WIDTH, d3
00001984                          1031      
00001984                          1032      ;Move the players current position to the Bullet Coordinate tables, so we can init the bullet position relative to the player
00001984  22C1                    1033      move.l d1, (a1)+
00001986  2A02                    1034      move.l d2, d5
00001988  E085                    1035      asr.l #8, d5
0000198A  24C5                    1036      move.l d5, (a2)+
0000198C  26C3                    1037      move.l d3, (a3)+
0000198E  28C4                    1038      move.l d4, (a4)+
00001990                          1039      
00001990                          1040      ;Add 1 to number of bullets
00001990  2C15                    1041      move.l (a5), d6
00001992  5286                    1042      addi.l #1, d6
00001994  2A86                    1043      move.l d6, (a5)
00001996                          1044      
00001996                          1045      ;Change value of bulletActive flag so we know we're firing a shot
00001996  2CBC 00000001           1046      move.l #1, (a6)
0000199C                          1047      
0000199C  4CDF 7FFF               1048      movem.l (sp)+, ALL_REG
000019A0  4E75                    1049      rts
000019A2                          1050  
000019A2                          1051  subtractOne2:
000019A2  0487 00000023           1052      subi.l #PLAYER_RIGHT_VELOCITY, d7
000019A8  2087                    1053      move.l d7, (a0)
000019AA  4CDF 7FFF               1054      movem.l (sp)+, ALL_REG
000019AE  4E75                    1055      rts
000019B0                          1056  addOne2:
000019B0  0687 00000023           1057      addi.l #-PLAYER_LEFT_VELOCITY, d7
000019B6  2087                    1058      move.l d7, (a0)
000019B8  4CDF 7FFF               1059      movem.l (sp)+, ALL_REG
000019BC  4E75                    1060      rts
000019BE                          1061  return2:
000019BE  2087                    1062      move.l d7, (a0)
000019C0  4CDF 7FFF               1063      movem.l (sp)+, ALL_REG
000019C4  4E75                    1064      rts
000019C6                          1065  
000019C6                          1066  drawPlayer2:
000019C6  48E7 FFFE               1067      movem.l ALL_REG, -(sp)
000019CA                          1068      
000019CA  41F9 00001A20           1069      lea player2X1, a0
000019D0  43F9 00001A28           1070      lea player2Y1, a1
000019D6  45F9 00001A24           1071      lea player2X2, a2
000019DC  47F9 00001A2C           1072      lea player2Y2, a3
000019E2  2E10                    1073      move.l (a0), d7
000019E4  2411                    1074      move.l (a1), d2
000019E6  2612                    1075      move.l (a2), d3
000019E8  2813                    1076      move.l (a3), d4
000019EA                          1077      
000019EA  223C 00008000           1078      move.l #GREEN, d1
000019F0  103C 0050               1079      move.b #SET_PEN_COLOR_COMMAND, d0
000019F4  4E4F                    1080      trap #15
000019F6  103C 0051               1081      move.b #SET_FILL_COLOR_COMMAND, d0
000019FA  4E4F                    1082      trap #15
000019FC  103C 0057               1083      move.b #DRAW_RECTANGLE_COMMAND, d0
00001A00                          1084      
00001A00                          1085      *Shift to get the value of the X coordinates since we're using fixed point math
00001A00  2207                    1086      move.l d7, d1
00001A02  E081                    1087      asr.l #8, d1
00001A04  2601                    1088      move.l d1, d3
00001A06  0683 00000014           1089      add.l #PLAYER_WIDTH, d3
00001A0C                          1090      
00001A0C                          1091      *Shift to get the value of the Y coordinates since we're using fixed point math
00001A0C  E082                    1092      asr.l #8, d2
00001A0E  E082                    1093      asr.l #8, d2
00001A10  2802                    1094      move.l d2, d4
00001A12  0684 00000014           1095      add.l #PLAYER_HEIGHT, d4
00001A18  4E4F                    1096      trap #15
00001A1A                          1097      
00001A1A                          1098      *Reset the players Y position
00001A1A                          1099      ;move.l #PLAYER_TOP_Y_POSITION,d2
00001A1A                          1100      
00001A1A                          1101      *Store the value of the current position of player in table
00001A1A                          1102      
00001A1A                          1103      ;move.l d1, (a1)
00001A1A                          1104      ;move.l d3, (a2)
00001A1A                          1105      ;move.l d2, (a3)
00001A1A                          1106      ;move.l d4, (a4)
00001A1A                          1107     
00001A1A  4CDF 7FFF               1108      movem.l (sp)+, ALL_REG
00001A1E                          1109      
00001A1E  4E75                    1110      rts
00001A20                          1111  
00001A20                          1112  player2X1 ds.l 1
00001A24                          1113  player2X2 ds.l 1
00001A28                          1114  player2Y1 ds.l 1
00001A2C                          1115  player2Y2 ds.l 1
00001A30                          1116  
00001A30                          1117  numBullets2 ds.l 1
00001A34                          1118  
00001A34                          1119  bulletTable2X1 ds.l 20
00001A84                          1120  bulletTable2X2 ds.l 20
00001AD4                          1121  bulletTable2Y1 ds.l 20
00001B24                          1122  bulletTable2Y2 ds.l 20 
00001B74                          1123  
00001B74= 00000000                1124  bullet2Active dc.l 0
00001B78                          1125  
00001B78                          1126  
00001B78                          1127  
00001B78                          1128  
00001B78                          1129  -------------------- end include --------------------
00001B78                          1130      INCLUDE "Bullet2.x68"
00001B78                          1131  
00001B78                          1132  ALL_REG reg D0-D7/A0-A6
00001B78                          1133  
00001B78                          1134  ;Trap code commands for Bullet
00001B78  =00000050               1135  SET_PEN_COLOR_COMMAND equ 80
00001B78  =00000051               1136  SET_FILL_COLOR_COMMAND equ 81
00001B78  =00000058               1137  DRAW_CIRCLE_COMMAND equ 88
00001B78  =00000013               1138  GET_USER_INPUT_COMMAND equ 19
00001B78                          1139  
00001B78                          1140  ;EQU values for player height/width, starting position, boundaries, and velocity
00001B78  =00000010               1141  BULLET_WIDTH equ 16
00001B78  =00000010               1142  BULLET_HEIGHT equ 16
00001B78  =0001B328               1143  BULLET_TOP_Y_POSITION equ 111400
00001B78  =00000028               1144  BULLET_STARTING_X_POSITION equ 40
00001B78  =0000002D               1145  BULLET_VELOCITY equ 45
00001B78  =00000001               1146  BULLET_ACCELERATION equ 1
00001B78  =00000000               1147  TOP_SIDE_OF_SCREEN equ 0
00001B78                          1148  
00001B78  =00800080               1149  PURPLE equ $00800080
00001B78  =00FF00FF               1150  FUSCHIA equ $00FF00FF
00001B78                          1151  
00001B78                          1152  checkNumBullets2:  
00001B78  48E7 FFFE               1153      movem.l ALL_REG, -(sp)
00001B7C                          1154    
00001B7C                          1155      *Compare numBullets to 0. If not 0, then we must update/draw bullets
00001B7C  43F8 1A30               1156      lea numBullets2, a1
00001B80  2A11                    1157      move.l (a1), d5
00001B82  0C85 00000000           1158      cmpi.l #0, d5
00001B88                          1159      
00001B88  4CDF 7FFF               1160      movem.l (sp)+, ALL_REG
00001B8C  4E75                    1161      rts
00001B8E                          1162   
00001B8E                          1163  updateBullet2:
00001B8E  48E7 FFFE               1164      movem.l ALL_REG, -(sp)
00001B92                          1165      
00001B92                          1166      *Get current Y coordinate of the bullet, and add velocity to change position
00001B92  43F8 1AD4               1167      lea bulletTable2Y1, a1
00001B96  45F8 1A34               1168      lea bulletTable2X1, a2
00001B9A  7A2D                    1169      move.l #BULLET_VELOCITY, d5
00001B9C  2C11                    1170      move.l (a1), d6
00001B9E  9C85                    1171      sub.l d5,d6
00001BA0                          1172  
00001BA0                          1173     *Comparison to make sure we don't go beyond the bounds of the top of the screen
00001BA0                          1174     *If we do, delete the bulelt
00001BA0  0C86 00000000           1175      cmpi.l #(TOP_SIDE_OF_SCREEN)<<8, d6
00001BA6  6F00 005C               1176      ble deleteBullet2
00001BAA                          1177      
00001BAA  0C92 0000002D           1178      cmpi.l #45, (a2)
00001BB0  6F00 0052               1179      ble deleteBullet2
00001BB4                          1180      
00001BB4                          1181  returnFromDelete2:
00001BB4  2286                    1182      move.l d6, (a1)
00001BB6                          1183          
00001BB6  4CDF 7FFF               1184      movem.l (sp)+,ALL_REG
00001BBA                          1185      
00001BBA  4E75                    1186      rts 
00001BBC                          1187              
00001BBC                          1188  drawBullet2:
00001BBC  48E7 FFFE               1189      movem.l ALL_REG, -(sp)
00001BC0                          1190      
00001BC0  223C 00FF00FF           1191      move.l #FUSCHIA, d1
00001BC6  103C 0050               1192      move.b #SET_PEN_COLOR_COMMAND, d0
00001BCA  4E4F                    1193      trap #15
00001BCC  103C 0051               1194      move.b #SET_FILL_COLOR_COMMAND, d0
00001BD0  4E4F                    1195      trap #15
00001BD2                          1196      
00001BD2                          1197      *Load the bullet's coordinates from the table, shift accordingly due to fixed point,
00001BD2                          1198      *and draw the bullet at the current positio
00001BD2  103C 0058               1199      move.b #DRAW_CIRCLE_COMMAND, d0
00001BD6  43F8 1A34               1200      lea bulletTable2X1, a1
00001BDA  45F8 1AD4               1201      lea bulletTable2Y1, a2
00001BDE  47F8 1A84               1202      lea bulletTable2X2, a3
00001BE2  49F8 1B24               1203      lea bulletTable2Y2, a4    
00001BE6  2211                    1204      move.l (a1), d1
00001BE8  2412                    1205      move.l (a2), d2
00001BEA  E082                    1206      asr.l #8, d2
00001BEC  2802                    1207      move.l d2, d4
00001BEE  0684 00000010           1208      add.l #BULLET_HEIGHT, d4
00001BF4  2601                    1209      move.l d1, d3
00001BF6  0683 00000010           1210      add.l #BULLET_WIDTH, d3
00001BFC  4E4F                    1211      trap #15
00001BFE                          1212      
00001BFE                          1213  
00001BFE  4CDF 7FFF               1214      movem.l (sp)+, ALL_REG
00001C02  4E75                    1215      rts
00001C04                          1216  
00001C04                          1217  deleteBullet2:
00001C04                          1218      *All we have to do to 'delete' the bullet is decrease the value of numBullets
00001C04                          1219      *This effectively stops the bullet from being updated/printed
00001C04  47F8 1A30               1220      lea numBullets2, a3
00001C08  5393                    1221      subi.l #1, (a3)
00001C0A                          1222      ;move.l #1, (a2)
00001C0A                          1223      
00001C0A  60A8                    1224      bra returnFromDelete2
00001C0C                          1225  
00001C0C= 00000001                1226  bullet2Velocity dc.l 1
00001C10                          1227  
00001C10                          1228  
00001C10                          1229  
00001C10                          1230  
00001C10                          1231  
00001C10                          1232  
00001C10                          1233  
00001C10                          1234  
00001C10                          1235  
00001C10                          1236  
00001C10                          1237  
00001C10                          1238      
00001C10                          1239  
00001C10                          1240  
00001C10                          1241  
00001C10                          1242  
00001C10                          1243  
00001C10                          1244  
00001C10                          1245  
00001C10                          1246  
00001C10                          1247  
00001C10                          1248  
00001C10                          1249  
00001C10                          1250  
00001C10                          1251  -------------------- end include --------------------
00001C10                          1252      INCLUDE "LED2.x68"
00001C10                          1253  
00001C10                          1254  ALL_DATA_REG reg d0-d7
00001C10  =0000000E               1255  PRINT_TEXT_COMMAND equ 14
00001C10  =00000050               1256  SET_PEN_COLOR_COMMAND equ 80
00001C10  =00000051               1257  SET_FILL_COLOR_COMMAND equ 81
00001C10  =00000057               1258  DRAW_RECTANGLE_COMMAND equ 87
00001C10                          1259  
00001C10                          1260  ;LEFT_X_COORDINATE equ 20
00001C10                          1261  ;RIGHT_X_COORDINATE equ 30
00001C10  =000000C8               1262  TOP_Y_COORDINATE2 equ 200
00001C10  =000000D2               1263  MIDDLE_Y_COORDINATE2 equ 210
00001C10  =000000DC               1264  BOTTOM_Y_COORDINATE2 equ 220
00001C10  =00000006               1265  COORDINATE_OFFSET equ 6
00001C10  =0000000F               1266  PRINT_OFFSET equ 15
00001C10                          1267  
00001C10  =00000039               1268  TEST_NUMBER equ 57   
00001C10                          1269   
00001C10  =00FFFFFF               1270  WHITE equ $00FFFFFF   
00001C10                          1271  
00001C10                          1272  updateScore2:
00001C10  48E7 FFFE               1273      movem.l ALL_REG, -(sp)
00001C14                          1274    
00001C14  4283                    1275      clr.l d3
00001C16  4284                    1276      clr.l d4   
00001C18                          1277      
00001C18  41F9 00001D18           1278      lea printFlag2, a0
00001C1E  10BC 0000               1279      move.b #0, (a0)
00001C22                          1280      
00001C22                          1281      *Load the current score that we need to draw, as well as the tables that hold the 
00001C22                          1282      *bitmask for our 7 segment LED, and the coordinates for each of the segments
00001C22  41F8 167A               1283      lea player2Score, a0
00001C26  2A10                    1284      move.l (a0),d5
00001C28  41F8 17E2               1285      lea sevenSegmentTable, a0
00001C2C  43F9 00001D10           1286      lea coordinateTableOffset2, a1
00001C32  45F8 17EC               1287      lea coordinateTableX1, a2
00001C36  47F9 00001D02           1288      lea coordinateTable2Y1, a3
00001C3C  49F8 17F3               1289      lea coordinateTableX2, a4
00001C40  4BF9 00001D09           1290      lea coordinateTable2Y2, a5
00001C46  4DF9 00001D14           1291      lea printOffset2, a6
00001C4C                          1292      
00001C4C  1CBC 0000               1293      move.b #0, (a6)
00001C50                          1294      
00001C50                          1295  ;d0 - trap codes
00001C50                          1296  ;d5 - number to print
00001C50                          1297  ;d6 - single digit to print
00001C50                          1298  ;d3 - value of segment to print
00001C50                          1299  ;d4 - AND register  
00001C50                          1300  readDigit2:
00001C50                          1301      
00001C50                          1302      *Set value of the coordinate offset used to index segment coordinate table
00001C50  12BC 0006               1303      move.b #COORDINATE_OFFSET, (a1)
00001C54                          1304      
00001C54                          1305      *Divide the current score by 10, then swap to get the remainder
00001C54                          1306      *This remainder will give us the one's digit we need to draw
00001C54  8AFC 000A               1307      divu #10, d5
00001C58  4845                    1308      swap d5
00001C5A  3C05                    1309      move.w d5, d6
00001C5C                          1310      
00001C5C                          1311      *Using the digit itself as an offset, go into the segment table to find out which number needs to be drawn
00001C5C  1630 6000               1312      move.b (a0, d6), d3
00001C60  2803                    1313      move.l d3, d4
00001C62                          1314  
00001C62                          1315  loop2:    
00001C62                          1316      *And 1 to see if the lowest bit is set, to see which segment needs to be drawn
00001C62                          1317      *If the bit is set to 0, segment must not be drawn, and we must shift down one
00001C62  0284 00000001           1318      andi.l #1, d4
00001C68  6700 0038               1319      beq shift2
00001C6C                          1320    
00001C6C                          1321  drawSegment2:
00001C6C  48E7 FF00               1322      movem.l ALL_DATA_REG, -(sp)
00001C70                          1323      
00001C70  7050                    1324      move.l #SET_PEN_COLOR_COMMAND, d0
00001C72  223C 00FFFFFF           1325      move.l #WHITE, d1
00001C78  4E4F                    1326      trap #15
00001C7A                          1327      
00001C7A  4240                    1328      clr d0
00001C7C  4281                    1329      clr.l d1
00001C7E  4282                    1330      clr.l d2
00001C80  4283                    1331      clr.l d3
00001C82  4284                    1332      clr.l d4
00001C84                          1333      
00001C84                          1334      *If we reach here, we know which digit to draw, which segment to draw, so get the coordinates of each segment to draw
00001C84                          1335      *from the Segment coordinate table
00001C84  1011                    1336      move.b (a1), d0
00001C86  1232 0000               1337      move.b (a2, d0), d1
00001C8A  D216                    1338      add.b (a6), d1
00001C8C  1433 0000               1339      move.b (a3, d0), d2
00001C90  1634 0000               1340      move.b (a4, d0), d3
00001C94  D616                    1341      add.b (a6), d3
00001C96  1835 0000               1342      move.b (a5, d0), d4
00001C9A                          1343      
00001C9A  7057                    1344      move.l #DRAW_RECTANGLE_COMMAND, d0
00001C9C  4E4F                    1345      trap #15
00001C9E                          1346      
00001C9E  4CDF 00FF               1347      movem.l (sp)+, ALL_DATA_REG
00001CA2                          1348      
00001CA2                          1349  shift2:
00001CA2                          1350      *Shift bitmask by 1 since we didn't draw last segment
00001CA2  E24B                    1351      lsr #1, d3
00001CA4                          1352      
00001CA4                          1353      *Check if the value after shift is 0. If so, we're done this digit, so move onto the next one.
00001CA4  0C83 00000000           1354      cmpi.l #0, d3
00001CAA  6700 0008               1355      beq upperSwap2
00001CAE                          1356      
00001CAE                          1357      *If reach here, we still have segments left to draw
00001CAE                          1358      *Move the current segment back into the reg, and go back to the drawing loop 
00001CAE  2803                    1359      move.l d3, d4
00001CB0  5311                    1360      subi.b #1, (a1)
00001CB2  60AE                    1361      bra loop2  
00001CB4                          1362   
00001CB4                          1363  upperSwap2:
00001CB4                          1364      *Load the print flag, add 1, and check if the value is 2
00001CB4                          1365      *If so, we printed all digits, so stop printing the score
00001CB4  4DF9 00001D18           1366      lea printFlag2, a6
00001CBA  2016                    1367      move.l (a6), d0
00001CBC  5280                    1368      addi.l #1, d0
00001CBE  2C80                    1369      move.l d0, (a6)
00001CC0  0C80 00000001           1370      cmpi.l #1, d0
00001CC6  6700 001E               1371      beq stopPrinting2
00001CCA                          1372      
00001CCA                          1373      *If we reach here, reset the coordinate offset,
00001CCA                          1374      *and swap the value in d5, since before we had the ones digit, now we need the tens digit
00001CCA  12BC 0006               1375      move.b #COORDINATE_OFFSET, (a1)
00001CCE  4845                    1376      swap d5
00001CD0  3C05                    1377      move.w d5, d6
00001CD2                          1378      
00001CD2                          1379      *Set the offset for printing the tens digit, since the tens digit needs to be offset to the left of the ones digit
00001CD2  4DF9 00001D14           1380      lea printOffset2, a6
00001CD8  0416 000F               1381      subi.b #PRINT_OFFSET, (a6)
00001CDC                          1382         
00001CDC  1630 6000               1383      move.b (a0, d6), d3
00001CE0  2803                    1384      move.l d3, d4
00001CE2  6000 FA2E               1385      bra loop
00001CE6                          1386   
00001CE6                          1387  stopPrinting2:
00001CE6                          1388      *Reset the print offset, and return
00001CE6  4DF9 00001D18           1389      lea printFlag2, a6 
00001CEC  2CBC 00000000           1390      move.l #0, (a6)
00001CF2  4DF9 00001D14           1391      lea printOffset2, a6
00001CF8  1CBC 0000               1392      move.b #0, (a6)
00001CFC                          1393      
00001CFC  4CDF 7FFF               1394      movem.l (sp)+,ALL_REG
00001D00  4E75                    1395      rts
00001D02                          1396  
00001D02                          1397  
00001D02                          1398  
00001D02                          1399  
00001D02= C8                      1400  coordinateTable2Y1: dc.b TOP_Y_COORDINATE2     ;A
00001D03= C8                      1401                      dc.b TOP_Y_COORDINATE2     ;B
00001D04= D2                      1402                      dc.b MIDDLE_Y_COORDINATE2  ;C
00001D05= DC                      1403                      dc.b BOTTOM_Y_COORDINATE2  ;D
00001D06= DC                      1404                      dc.b BOTTOM_Y_COORDINATE2  ;E
00001D07= D2                      1405                      dc.b MIDDLE_Y_COORDINATE2  ;F
00001D08= D2                      1406                      dc.b MIDDLE_Y_COORDINATE2  ;G
00001D09                          1407  
00001D09= C8                      1408  coordinateTable2Y2: dc.b TOP_Y_COORDINATE2     ;A
00001D0A= D2                      1409                      dc.b MIDDLE_Y_COORDINATE2  ;B
00001D0B= DC                      1410                      dc.b BOTTOM_Y_COORDINATE2  ;C
00001D0C= DC                      1411                      dc.b BOTTOM_Y_COORDINATE2  ;D
00001D0D= D2                      1412                      dc.b MIDDLE_Y_COORDINATE2  ;E
00001D0E= C8                      1413                      dc.b TOP_Y_COORDINATE2     ;F
00001D0F= D2                      1414                      dc.b MIDDLE_Y_COORDINATE2  ;G  
00001D10                          1415  
00001D10                          1416  
00001D10                          1417  
00001D10                          1418  
00001D10= 00000006                1419  coordinateTableOffset2 dc.l 6
00001D14                          1420  
00001D14= 00000000                1421  printOffset2 dc.l 0
00001D18                          1422  
00001D18= 00000000                1423  printFlag2 dc.l 0
00001D1C                          1424  
00001D1C= 00000000                1425  padding dc.l 0
00001D20                          1426  
00001D20                          1427  
00001D20                          1428  
00001D20                          1429  
00001D20                          1430  
00001D20                          1431  
00001D20                          1432  
00001D20                          1433  
00001D20                          1434  
00001D20                          1435  
00001D20                          1436  
00001D20                          1437  -------------------- end include --------------------
00001D20                          1438      INCLUDE "ClearScreen.x68"
00001D20                          1439  
00001D20  =00000000               1440  BITMAP_CHUNK_TOP_X EQU 0
00001D20  =00000000               1441  BITMAP_CHUNK_TOP_Y EQU 0
00001D20  =00000028               1442  BITMAP_CHUNK_WIDTH EQU 40
00001D20  =000000F0               1443  BITMAP_CHUNK_HEIGHT EQU 240
00001D20  =000000F0               1444  BITMAP_CHUNK_Y_START_POS EQU BITMAP_CHUNK_TOP_Y+BITMAP_CHUNK_HEIGHT
00001D20  =00000028               1445  BITMAP_CHUNK_X_END_POS EQU BITMAP_CHUNK_TOP_X+BITMAP_CHUNK_WIDTH
00001D20  =00000000               1446  PRINT_TOP_X EQU 0
00001D20  =00000000               1447  PRINT_TOP_Y EQU 0
00001D20  =00000002               1448  BMP_FILE_SIZE_OFFSET EQU 2
00001D20  =0000000A               1449  BMP_START_ADDRESS_OFFSET EQU 10
00001D20  =00000012               1450  BMP_WIDTH_OFFSET EQU 18
00001D20  =00000016               1451  BMP_HEIGHT_OFFSET EQU 22
00001D20  =0000001C               1452  BMP_BITDEPTH_OFFSET EQU 28
00001D20                          1453  
00001D20  =00000033               1454  OPEN_EXISTING_FILE_TRAP_CODE EQU 51 
00001D20  =00000034               1455  OPEN_NEW_FILE_TRAP_CODE EQU 52
00001D20  =00000035               1456  READ_FILE_TRAP_CODE EQU 53
00001D20  =0000003A               1457  DISPLAY_FILE_TRAP_CODE EQU 58
00001D20  =00000050               1458  PEN_COLOR_TRAP_CODE EQU 80
00001D20  =00000052               1459  DRAW_PIXEL_TRAP_CODE EQU 82
00001D20  =00000050               1460  SET_PEN_COLOR_COMMAND equ 80
00001D20  =00000051               1461  SET_FILL_COLOR_COMMAND equ 81
00001D20  =00000057               1462  DRAW_RECTANGLE_COMMAND equ 87
00001D20                          1463  
00001D20  =00000000               1464  BLACK equ $00000000
00001D20                          1465  
00001D20                          1466  fakeClearScreen:
00001D20  48E7 FFFE               1467      movem.l ALL_REG, -(sp)
00001D24                          1468      
00001D24  7200                    1469      move.l #BLACK, d1
00001D26  103C 0050               1470      move.b #SET_PEN_COLOR_COMMAND, d0
00001D2A  4E4F                    1471      trap #15
00001D2C  103C 0051               1472      move.b #SET_FILL_COLOR_COMMAND, d0
00001D30  4E4F                    1473      trap #15
00001D32  103C 0057               1474      move.b #DRAW_RECTANGLE_COMMAND, d0
00001D36                          1475      
00001D36  7228                    1476      move.l #40, d1
00001D38  7400                    1477      move.l #0, d2
00001D3A  263C 00000280           1478      move.l #640, d3
00001D40  283C 000001E0           1479      move.l #480, d4
00001D46  4E4F                    1480      trap #15
00001D48                          1481      
00001D48  7200                    1482      move.l #0, d1
00001D4A  243C 000000FA           1483      move.l #250, d2
00001D50  263C 00000280           1484      move.l #640, d3
00001D56  283C 000001E0           1485      move.l #480, d4
00001D5C  4E4F                    1486      trap #15
00001D5E                          1487      
00001D5E  4CDF 7FFF               1488      movem.l (sp)+, ALL_REG
00001D62  4E75                    1489      rts
00001D64                          1490      
00001D64                          1491  drawBitmap:
00001D64                          1492  ;PrintCrop:
00001D64                          1493  ;Reads the size of the bmp in bytes, and grabs offset for starting location of pixel array, store both in mem     
00001D64                          1494      ;First grab the size of the file
00001D64  48E7 FFFE               1495       movem.l ALL_REG, -(sp)
00001D68                          1496       
00001D68  43F9 00001EF8           1497       lea bmpFile,a1
00001D6E  45F9 00001EE2           1498       lea bmpFileSize, a2
00001D74  2229 0002               1499       move.l BMP_FILE_SIZE_OFFSET(a1), d1
00001D78                          1500       
00001D78                          1501      ;Size is written in Litten-Endian, so rol -> swap -> rol to get Big-Endian val
00001D78  E159                    1502       rol.w #8, d1                   
00001D7A  4841                    1503       swap.w d1
00001D7C  E159                    1504       rol.w #8, d1
00001D7E  2481                    1505       move.l d1, (a2)                ;Save Big-Endian value to memory
00001D80                          1506       
00001D80                          1507       
00001D80                          1508       ;Now grab offset for start of pixel data (also Little-Endian, so must convert), and store in memory
00001D80  45F9 00001EE6           1509       lea bmpPixelOffset, a2
00001D86  2429 000A               1510       move.l BMP_START_ADDRESS_OFFSET(a1), d2
00001D8A  4842                    1511       swap.w d2
00001D8C  E15A                    1512       rol.w #8, d2
00001D8E  2482                    1513       move.l d2, (a2)
00001D90                          1514  
00001D90                          1515       
00001D90                          1516  ;Now grab the Width, Height, Bit Depth, calculate padding, and store them in mem:
00001D90  43F9 00001EF8           1517       lea bmpFile, a1
00001D96  45F9 00001EEA           1518       lea bmpFileWidth, a2
00001D9C  47F9 00001EEE           1519       lea bmpFileHeight, a3
00001DA2  49F9 00001EF6           1520       lea bmpFilePadding, a4
00001DA8  4BF9 00001EF2           1521       lea bmpBitDepth, a5
00001DAE                          1522       
00001DAE  2229 0012               1523       move.l BMP_WIDTH_OFFSET(a1), d1
00001DB2  2429 0016               1524       move.l BMP_HEIGHT_OFFSET(a1), d2
00001DB6  2629 001C               1525       move.l BMP_BITDEPTH_OFFSET(a1), d3
00001DBA                          1526       
00001DBA                          1527       ;Again, switching from Little-Endian -> Big-Endian
00001DBA  4841                    1528       swap.w d1
00001DBC  E159                    1529       rol.w #8, d1
00001DBE  4842                    1530       swap.w d2
00001DC0  E15A                    1531       rol.w #8, d2
00001DC2  4843                    1532       swap.w d3
00001DC4  E15B                    1533       rol.w #8, d3
00001DC6                          1534       
00001DC6  3481                    1535       move.w d1, (a2)
00001DC8  3682                    1536       move.w d2, (a3)
00001DCA  3A83                    1537       move.w d3, (a5)
00001DCC  84FC 0004               1538       divu #4, d2
00001DD0                          1539       
00001DD0  4842                    1540       swap d2            ;Padding
00001DD2  3882                    1541       move.w d2, (a4)
00001DD4                          1542       
00001DD4                          1543       
00001DD4                          1544  ;Add pixel offset to starting address of bitmap to start reading pixels
00001DD4  4241                    1545      clr d1
00001DD6  4242                    1546      clr d2
00001DD8  45F9 00001EE6           1547      lea bmpPixelOffset, a2
00001DDE  2412                    1548      move.l (a2), d2
00001DE0  D3C2                    1549      adda.l d2, a1
00001DE2                          1550  
00001DE2                          1551  ;Prepare regs for drawing loop
00001DE2                          1552  ;d0 - Trap Code
00001DE2                          1553  ;d1 - 2 purposes; hold value for pixel color, and then hold value of X-coord for drawing
00001DE2                          1554  ;d2 - Holds value of Y-coord for drawing, initialized to Height, but changes to BITMAP_CHUNK_Y_START_POS for crop
00001DE2                          1555  ;d3 - Holds the value of the width of the file, used to compare agains the X-coord
00001DE2                          1556  ;d4 - Since d1 has 2 purposes, we need to save off the position of the X-coord when we reset pixel color, so store into d4 before loop restarts
00001DE2                          1557  ;d5 - Number of bytes to skip to get to start of crop
00001DE2                          1558  ;d6 - Number of bytes to skip on each iteration of loop
00001DE2                          1559  ;d7 - Extra reg to copy values and add/divide
00001DE2                          1560  
00001DE2  4240                    1561      clr d0
00001DE4  4241                    1562      clr d1
00001DE6  4242                    1563      clr d2
00001DE8                          1564      
00001DE8  45F9 00001EEA           1565      lea bmpFileWidth, a2
00001DEE  47F9 00001EEE           1566      lea bmpFileHeight, a3
00001DF4  49F9 00001EF6           1567      lea bmpFilePadding, a4
00001DFA  4BF9 00001EF2           1568      lea bmpBitDepth, a5
00001E00  3612                    1569      move.w (a2), d3
00001E02  3413                    1570      move.w (a3), d2
00001E04  3E15                    1571      move.w (a5), d7
00001E06  0C47 0020               1572      cmpi.w #32, d7                  ;Check the bit depth of the file, depending if 24 or 32 bit, our math slightly changes
00001E0A  6700 0038               1573      beq BitDepth32
00001E0E                          1574  
00001E0E                          1575  ;Branch for 24bit files, will calculate how much of image to skip/crop
00001E0E                          1576  BitDepth24:    
00001E0E                          1577      ;This arithmetic will give us the number of bytes to skip to start our crop
00001E0E                          1578      ;Formula is: ((bmpFileHeight - (Bitmap_Chunk_Top_Y+Bitmap_Chunk_Height))*Bitmap_Chunk_Width + Bitmap_Chunk_Top_X
00001E0E  2A02                    1579      move.l d2, d5
00001E10  0485 000000F0           1580      sub.l  #BITMAP_CHUNK_Y_START_POS, d5
00001E16  CAC3                    1581      mulu d3, d5
00001E18  0685 00000000           1582      addi.l #BITMAP_CHUNK_TOP_X, d5
00001E1E  2E05                    1583      move.l d5, d7
00001E20  DA87                    1584      add.l d7, d5
00001E22  DA87                    1585      add.l d7, d5
00001E24                          1586      
00001E24  D3C5                    1587      adda.l d5, a1
00001E26                          1588      
00001E26                          1589      ;This arithmetic will give us the number of bytes to skip during each iteration of the loop
00001E26                          1590      ;Formual is: (bmpFileWidth - Bitmap_Chunk_Width) * 3
00001E26  2C03                    1591      move.l d3, d6
00001E28  0486 00000028           1592      subi.l #BITMAP_CHUNK_WIDTH, d6
00001E2E  2E06                    1593      move.l d6, d7
00001E30  DC87                    1594      add.l d7, d6
00001E32  DC87                    1595      add.l d7, d6
00001E34                          1596      
00001E34  243C 000000F0           1597      move.l #(PRINT_TOP_Y+BITMAP_CHUNK_HEIGHT), d2
00001E3A  7628                    1598      move.l #(PRINT_TOP_X+BITMAP_CHUNK_WIDTH), d3
00001E3C  7800                    1599      move.l #PRINT_TOP_X, d4
00001E3E                          1600      
00001E3E  4EF9 00001EA8           1601      jmp ContinueRow24
00001E44                          1602  
00001E44                          1603  ;Branch for 32 bit images, will calculate how much of the image to skip/crop    
00001E44                          1604  BitDepth32:
00001E44                          1605      ;This arithmetic will give us the number of bytes to skip to start our crop
00001E44                          1606      ;Formula is: ((bmpFileHeight - (Bitmap_Chunk_Top_Y+Bitmap_Chunk_Height))*Bitmap_Chunk_Width + Bitmap_Chunk_Top_X
00001E44  2A02                    1607      move.l d2, d5
00001E46  0485 000000F0           1608      sub.l  #BITMAP_CHUNK_Y_START_POS, d5
00001E4C  CAC3                    1609      mulu d3, d5
00001E4E  0685 00000000           1610      addi.l #BITMAP_CHUNK_TOP_X, d5
00001E54  2E05                    1611      move.l d5, d7
00001E56  DA87                    1612      add.l d7, d5
00001E58  DA87                    1613      add.l d7, d5
00001E5A  DA87                    1614      add.l d7, d5
00001E5C                          1615      
00001E5C  D3C5                    1616      adda.l d5, a1
00001E5E                          1617      
00001E5E                          1618      ;This arithmetic will give us the number of bytes to skip during each iteration of the loop
00001E5E                          1619      ;Formual is: (bmpFileWidth - Bitmap_Chunk_Width) * 4
00001E5E  2C03                    1620      move.l d3, d6
00001E60  0486 00000028           1621      subi.l #BITMAP_CHUNK_WIDTH, d6
00001E66  2E06                    1622      move.l d6, d7
00001E68  DC87                    1623      add.l d7, d6
00001E6A  DC87                    1624      add.l d7, d6
00001E6C  DC87                    1625      add.l d7, d6
00001E6E                          1626      
00001E6E  243C 000000F0           1627      move.l #(PRINT_TOP_Y+BITMAP_CHUNK_HEIGHT), d2
00001E74  7628                    1628      move.l #(PRINT_TOP_X+BITMAP_CHUNK_WIDTH), d3
00001E76  7800                    1629      move.l #PRINT_TOP_X, d4
00001E78                          1630    
00001E78                          1631    
00001E78                          1632  ;Loop to print the 32 bit file. 32 bit bitmaps have 4 bytes per pixel, so just move.l
00001E78                          1633  ContinueRow32:
00001E78  4241                    1634      clr d1 
00001E7A                          1635    
00001E7A  2219                    1636      move.l (a1)+, d1
00001E7C  E099                    1637      ror.l #8, d1
00001E7E  7050                    1638      move.l #PEN_COLOR_TRAP_CODE, d0
00001E80  4E4F                    1639      trap #15
00001E82  4241                    1640      clr d1
00001E84                          1641      
00001E84                          1642      ;d1 is being used twice in this loop (pixel color, and draw pixel x coordinate),
00001E84                          1643      ;so copy X-coord value into d4 every time to save, and move back during each iteration of the loop
00001E84  2204                    1644      move.l d4, d1
00001E86  7052                    1645      move.l #DRAW_PIXEL_TRAP_CODE, d0
00001E88  4E4F                    1646      trap #15
00001E8A                          1647      
00001E8A  5241                    1648      addi #1, d1                             ;Increment X-coord
00001E8C  2801                    1649      move.l d1, d4                           :Copy X-coord
00001E8E  B681                    1650      cmp.l d1, d3 
00001E90  66E6                    1651      bne ContinueRow32
00001E92  3E14                    1652      move.w (a4), d7                         ;Get file padding, add it to address when we reach end of row
00001E94  D3C7                    1653      adda.l d7, a1
00001E96  7200                    1654      move.l #PRINT_TOP_X, d1                 ;If we reach here, reset X-coord to default value (and copy into d4 to save)
00001E98  7800                    1655      move.l #PRINT_TOP_X, d4          
00001E9A  5382                    1656      subi.l #1, d2                           ;DECREMENT Y-coord, remember we start at BOTTOM not TOP of screen, so subtract
00001E9C  D3C6                    1657      adda.l d6, a1
00001E9E  0C82 00000000           1658      cmpi.l #PRINT_TOP_Y, d2
00001EA4  66D2                    1659      bne ContinueRow32
00001EA6                          1660      
00001EA6  4E75                    1661      rts
00001EA8                          1662  
00001EA8                          1663  ;Loop to print 24 bit file.then we calculate the crop position based on the input parameters we were given, and the amount of bytes to skip in the pixel array
00001EA8                          1664  ;as calculated above
00001EA8                          1665  ContinueRow24:
00001EA8  4241                    1666      clr d1 
00001EAA                          1667       
00001EAA                          1668      ;Grab the pixel color RGB value from the array. Since this works on 24-bit files, we cannot load in words or longs,
00001EAA                          1669      ;so we must load in the pixel values one byte at a time. After loading in the first byte, we must swap in order to put it into it's correct position
00001EAA                          1670      ;Then for the second byte we must read and roll it left 8 bytes to get THAT color in it's correct position
00001EAA  1219                    1671      move.b (a1)+, d1
00001EAC  4841                    1672      swap d1
00001EAE  1219                    1673      move.b (a1)+, d1
00001EB0  E159                    1674      rol.w #8, d1
00001EB2  1219                    1675      move.b (a1)+, d1
00001EB4  7050                    1676      move.l #PEN_COLOR_TRAP_CODE, d0
00001EB6  4E4F                    1677      trap #15
00001EB8  4241                    1678      clr d1
00001EBA                          1679      
00001EBA                          1680      ;d1 is being used twice in this loop (pixel color, and draw pixel x coordinate),
00001EBA                          1681      ;so copy X-coord value into d4 every time to save, and move back during each iteration of the loop
00001EBA  2204                    1682      move.l d4, d1
00001EBC  7052                    1683      move.l #DRAW_PIXEL_TRAP_CODE, d0
00001EBE  4E4F                    1684      trap #15
00001EC0                          1685      
00001EC0  5241                    1686      addi #1, d1                             ;Increment X-coord
00001EC2  2801                    1687      move.l d1, d4                           :Copy X-coord
00001EC4  B681                    1688      cmp.l d1, d3 
00001EC6  66E0                    1689      bne ContinueRow24
00001EC8  3E14                    1690      move.w (a4), d7                         ;Get file padding, add it to address when we reach end of row
00001ECA  D3C7                    1691      adda.l d7, a1
00001ECC  7200                    1692      move.l #PRINT_TOP_X, d1                 ;If we reach here, reset X-coord to default value (and copy into d4 to save)
00001ECE  7800                    1693      move.l #PRINT_TOP_X, d4          
00001ED0  5382                    1694      subi.l #1, d2                           ;DECREMENT Y-coord, remember we start at BOTTOM not TOP of screen, so subtract
00001ED2  D3C6                    1695      adda.l d6, a1
00001ED4  0C82 00000000           1696      cmpi.l #PRINT_TOP_Y, d2
00001EDA  66CC                    1697      bne ContinueRow24
00001EDC                          1698     
00001EDC  4CDF 7FFF               1699      movem.l (sp)+, ALL_REG 
00001EE0  4E75                    1700      rts 
00001EE2                          1701      
00001EE2                          1702   
00001EE2                          1703      
00001EE2                          1704           
00001EE2                          1705  
00001EE2                          1706  
00001EE2                          1707  ;Mem to store the size of img file
00001EE2                          1708  bmpFileSize ds.l 1
00001EE6                          1709  
00001EE6                          1710  ;Mem to store offset of pixel array location in file
00001EE6                          1711  bmpPixelOffset ds.l 1
00001EEA                          1712  
00001EEA                          1713  ;Mem to store bitmap file width
00001EEA                          1714  bmpFileWidth ds.l 1
00001EEE                          1715  
00001EEE                          1716  ;Mem to store bitmap file height
00001EEE                          1717  bmpFileHeight ds.l 1
00001EF2                          1718  
00001EF2                          1719  ;Mem to store Bit Depth of file
00001EF2                          1720  bmpBitDepth ds.l 1
00001EF6                          1721  
00001EF6                          1722  ;Mem to store padding for file sizes non-divisible by 4
00001EF6                          1723  bmpFilePadding ds.w 1
00001EF8                          1724  
00001EF8                          1725  ;Mem to store actual array info of the bitmap, place in same directory as source file
00001EF8                          1726  bmpFile INCBIN 'paint.bmp'
0019C1AE                          1727  
0019C1AE                          1728  
0019C1AE                          1729  -------------------- end include --------------------
0019C1AE                          1730      INCLUDE "IntroScreen.x68"
0019C1AE                          1731  
0019C1AE  =00000000               1732  BITMAP_CHUNK_TOP_X2 EQU 0
0019C1AE  =00000000               1733  BITMAP_CHUNK_TOP_Y2 EQU 0
0019C1AE  =00000280               1734  BITMAP_CHUNK_WIDTH2 EQU 640
0019C1AE  =000001E0               1735  BITMAP_CHUNK_HEIGHT2 EQU 480
0019C1AE  =000001E0               1736  BITMAP_CHUNK_Y_START_POS2 EQU BITMAP_CHUNK_TOP_Y2+BITMAP_CHUNK_HEIGHT2
0019C1AE  =00000280               1737  BITMAP_CHUNK_X_END_POS2 EQU BITMAP_CHUNK_TOP_X2+BITMAP_CHUNK_WIDTH2
0019C1AE  =00000000               1738  PRINT_TOP_X2 EQU 0
0019C1AE  =00000000               1739  PRINT_TOP_Y2 EQU 0
0019C1AE                          1740  
0019C1AE                          1741  
0019C1AE                          1742  drawIntro:
0019C1AE                          1743  ;PrintCrop:
0019C1AE                          1744  ;Reads the size of the bmp in bytes, and grabs offset for starting location of pixel array, store both in mem     
0019C1AE                          1745      ;First grab the size of the file
0019C1AE  48E7 FFFE               1746       movem.l ALL_REG, -(sp)
0019C1B2                          1747       
0019C1B2  43F9 0019C34A           1748       lea bmpFile2,a1
0019C1B8  45F9 0019C334           1749       lea bmpFileSize2, a2
0019C1BE  2229 0002               1750       move.l BMP_FILE_SIZE_OFFSET(a1), d1
0019C1C2                          1751       
0019C1C2                          1752      ;Size is written in Litten-Endian, so rol -> swap -> rol to get Big-Endian val
0019C1C2  E159                    1753       rol.w #8, d1                   
0019C1C4  4841                    1754       swap.w d1
0019C1C6  E159                    1755       rol.w #8, d1
0019C1C8  2481                    1756       move.l d1, (a2)                ;Save Big-Endian value to memory
0019C1CA                          1757       
0019C1CA                          1758       
0019C1CA                          1759       ;Now grab offset for start of pixel data (also Little-Endian, so must convert), and store in memory
0019C1CA  45F9 0019C338           1760       lea bmpPixelOffset2, a2
0019C1D0  2429 000A               1761       move.l BMP_START_ADDRESS_OFFSET(a1), d2
0019C1D4  4842                    1762       swap.w d2
0019C1D6  E15A                    1763       rol.w #8, d2
0019C1D8  2482                    1764       move.l d2, (a2)
0019C1DA                          1765  
0019C1DA                          1766       
0019C1DA                          1767  ;Now grab the Width, Height, Bit Depth, calculate padding, and store them in mem:
0019C1DA  43F9 0019C34A           1768       lea bmpFile2, a1
0019C1E0  45F9 0019C33C           1769       lea bmpFileWidth2, a2
0019C1E6  47F9 0019C340           1770       lea bmpFileHeight2, a3
0019C1EC  49F9 0019C348           1771       lea bmpFilePadding2, a4
0019C1F2  4BF9 0019C344           1772       lea bmpBitDepth2, a5
0019C1F8                          1773       
0019C1F8  2229 0012               1774       move.l BMP_WIDTH_OFFSET(a1), d1
0019C1FC  2429 0016               1775       move.l BMP_HEIGHT_OFFSET(a1), d2
0019C200  2629 001C               1776       move.l BMP_BITDEPTH_OFFSET(a1), d3
0019C204                          1777       
0019C204                          1778       ;Again, switching from Little-Endian -> Big-Endian
0019C204  4841                    1779       swap.w d1
0019C206  E159                    1780       rol.w #8, d1
0019C208  4842                    1781       swap.w d2
0019C20A  E15A                    1782       rol.w #8, d2
0019C20C  4843                    1783       swap.w d3
0019C20E  E15B                    1784       rol.w #8, d3
0019C210                          1785       
0019C210  3481                    1786       move.w d1, (a2)
0019C212  3682                    1787       move.w d2, (a3)
0019C214  3A83                    1788       move.w d3, (a5)
0019C216  84FC 0004               1789       divu #4, d2
0019C21A                          1790       
0019C21A  4842                    1791       swap d2            ;Padding
0019C21C  3882                    1792       move.w d2, (a4)
0019C21E                          1793       
0019C21E                          1794       
0019C21E                          1795  ;Add pixel offset to starting address of bitmap to start reading pixels
0019C21E  4241                    1796      clr d1
0019C220  4242                    1797      clr d2
0019C222  45F9 0019C338           1798      lea bmpPixelOffset2, a2
0019C228  2412                    1799      move.l (a2), d2
0019C22A  D3C2                    1800      adda.l d2, a1
0019C22C                          1801  
0019C22C                          1802  ;Prepare regs for drawing loop
0019C22C                          1803  ;d0 - Trap Code
0019C22C                          1804  ;d1 - 2 purposes; hold value for pixel color, and then hold value of X-coord for drawing
0019C22C                          1805  ;d2 - Holds value of Y-coord for drawing, initialized to Height, but changes to BITMAP_CHUNK_Y_START_POS for crop
0019C22C                          1806  ;d3 - Holds the value of the width of the file, used to compare agains the X-coord
0019C22C                          1807  ;d4 - Since d1 has 2 purposes, we need to save off the position of the X-coord when we reset pixel color, so store into d4 before loop restarts
0019C22C                          1808  ;d5 - Number of bytes to skip to get to start of crop
0019C22C                          1809  ;d6 - Number of bytes to skip on each iteration of loop
0019C22C                          1810  ;d7 - Extra reg to copy values and add/divide
0019C22C                          1811  
0019C22C  4240                    1812      clr d0
0019C22E  4241                    1813      clr d1
0019C230  4242                    1814      clr d2
0019C232                          1815      
0019C232  45F9 0019C33C           1816      lea bmpFileWidth2, a2
0019C238  47F9 0019C340           1817      lea bmpFileHeight2, a3
0019C23E  49F9 0019C348           1818      lea bmpFilePadding2, a4
0019C244  4BF9 0019C344           1819      lea bmpBitDepth2, a5
0019C24A  3612                    1820      move.w (a2), d3
0019C24C  3413                    1821      move.w (a3), d2
0019C24E  3E15                    1822      move.w (a5), d7
0019C250  0C47 0020               1823      cmpi.w #32, d7                  ;Check the bit depth of the file, depending if 24 or 32 bit, our math slightly changes
0019C254  6700 003C               1824      beq BitDepth322
0019C258                          1825  
0019C258                          1826  ;Branch for 24bit files, will calculate how much of image to skip/crop
0019C258                          1827  BitDepth242:    
0019C258                          1828      ;This arithmetic will give us the number of bytes to skip to start our crop
0019C258                          1829      ;Formula is: ((bmpFileHeight - (Bitmap_Chunk_Top_Y+Bitmap_Chunk_Height))*Bitmap_Chunk_Width + Bitmap_Chunk_Top_X
0019C258  2A02                    1830      move.l d2, d5
0019C25A  0485 000001E0           1831      sub.l  #BITMAP_CHUNK_Y_START_POS2, d5
0019C260  CAC3                    1832      mulu d3, d5
0019C262  0685 00000000           1833      addi.l #BITMAP_CHUNK_TOP_X2, d5
0019C268  2E05                    1834      move.l d5, d7
0019C26A  DA87                    1835      add.l d7, d5
0019C26C  DA87                    1836      add.l d7, d5
0019C26E                          1837      
0019C26E  D3C5                    1838      adda.l d5, a1
0019C270                          1839      
0019C270                          1840      ;This arithmetic will give us the number of bytes to skip during each iteration of the loop
0019C270                          1841      ;Formual is: (bmpFileWidth - Bitmap_Chunk_Width) * 3
0019C270  2C03                    1842      move.l d3, d6
0019C272  0486 00000280           1843      subi.l #BITMAP_CHUNK_WIDTH2, d6
0019C278  2E06                    1844      move.l d6, d7
0019C27A  DC87                    1845      add.l d7, d6
0019C27C  DC87                    1846      add.l d7, d6
0019C27E                          1847      
0019C27E  243C 000001E0           1848      move.l #(PRINT_TOP_Y2+BITMAP_CHUNK_HEIGHT2), d2
0019C284  263C 00000280           1849      move.l #(PRINT_TOP_X2+BITMAP_CHUNK_WIDTH2), d3
0019C28A  7800                    1850      move.l #PRINT_TOP_X2, d4
0019C28C                          1851      
0019C28C  4EF9 0019C2FA           1852      jmp ContinueRow242
0019C292                          1853  
0019C292                          1854  ;Branch for 32 bit images, will calculate how much of the image to skip/crop    
0019C292                          1855  BitDepth322:
0019C292                          1856      ;This arithmetic will give us the number of bytes to skip to start our crop
0019C292                          1857      ;Formula is: ((bmpFileHeight - (Bitmap_Chunk_Top_Y+Bitmap_Chunk_Height))*Bitmap_Chunk_Width + Bitmap_Chunk_Top_X
0019C292  2A02                    1858      move.l d2, d5
0019C294  0485 000001E0           1859      sub.l  #BITMAP_CHUNK_Y_START_POS2, d5
0019C29A  CAC3                    1860      mulu d3, d5
0019C29C  0685 00000000           1861      addi.l #BITMAP_CHUNK_TOP_X2, d5
0019C2A2  2E05                    1862      move.l d5, d7
0019C2A4  DA87                    1863      add.l d7, d5
0019C2A6  DA87                    1864      add.l d7, d5
0019C2A8  DA87                    1865      add.l d7, d5
0019C2AA                          1866      
0019C2AA  D3C5                    1867      adda.l d5, a1
0019C2AC                          1868      
0019C2AC                          1869      ;This arithmetic will give us the number of bytes to skip during each iteration of the loop
0019C2AC                          1870      ;Formual is: (bmpFileWidth - Bitmap_Chunk_Width) * 4
0019C2AC  2C03                    1871      move.l d3, d6
0019C2AE  0486 00000280           1872      subi.l #BITMAP_CHUNK_WIDTH2, d6
0019C2B4  2E06                    1873      move.l d6, d7
0019C2B6  DC87                    1874      add.l d7, d6
0019C2B8  DC87                    1875      add.l d7, d6
0019C2BA  DC87                    1876      add.l d7, d6
0019C2BC                          1877      
0019C2BC  243C 000001E0           1878      move.l #(PRINT_TOP_Y2+BITMAP_CHUNK_HEIGHT2), d2
0019C2C2  263C 00000280           1879      move.l #(PRINT_TOP_X2+BITMAP_CHUNK_WIDTH2), d3
0019C2C8  7800                    1880      move.l #PRINT_TOP_X2, d4
0019C2CA                          1881    
0019C2CA                          1882    
0019C2CA                          1883  ;Loop to print the 32 bit file. 32 bit bitmaps have 4 bytes per pixel, so just move.l
0019C2CA                          1884  ContinueRow322:
0019C2CA  4241                    1885      clr d1 
0019C2CC                          1886    
0019C2CC  2219                    1887      move.l (a1)+, d1
0019C2CE  E099                    1888      ror.l #8, d1
0019C2D0  7050                    1889      move.l #PEN_COLOR_TRAP_CODE, d0
0019C2D2  4E4F                    1890      trap #15
0019C2D4  4241                    1891      clr d1
0019C2D6                          1892      
0019C2D6                          1893      ;d1 is being used twice in this loop (pixel color, and draw pixel x coordinate),
0019C2D6                          1894      ;so copy X-coord value into d4 every time to save, and move back during each iteration of the loop
0019C2D6  2204                    1895      move.l d4, d1
0019C2D8  7052                    1896      move.l #DRAW_PIXEL_TRAP_CODE, d0
0019C2DA  4E4F                    1897      trap #15
0019C2DC                          1898      
0019C2DC  5241                    1899      addi #1, d1                             ;Increment X-coord
0019C2DE  2801                    1900      move.l d1, d4                           :Copy X-coord
0019C2E0  B681                    1901      cmp.l d1, d3 
0019C2E2  66E6                    1902      bne ContinueRow322
0019C2E4  3E14                    1903      move.w (a4), d7                         ;Get file padding, add it to address when we reach end of row
0019C2E6  D3C7                    1904      adda.l d7, a1
0019C2E8  7200                    1905      move.l #PRINT_TOP_X2, d1                 ;If we reach here, reset X-coord to default value (and copy into d4 to save)
0019C2EA  7800                    1906      move.l #PRINT_TOP_X2, d4          
0019C2EC  5382                    1907      subi.l #1, d2                           ;DECREMENT Y-coord, remember we start at BOTTOM not TOP of screen, so subtract
0019C2EE  D3C6                    1908      adda.l d6, a1
0019C2F0  0C82 00000000           1909      cmpi.l #PRINT_TOP_Y2, d2
0019C2F6  66D2                    1910      bne ContinueRow322
0019C2F8                          1911      
0019C2F8  4E75                    1912      rts
0019C2FA                          1913  
0019C2FA                          1914  ;Loop to print 24 bit file.then we calculate the crop position based on the input parameters we were given, and the amount of bytes to skip in the pixel array
0019C2FA                          1915  ;as calculated above
0019C2FA                          1916  ContinueRow242:
0019C2FA  4241                    1917      clr d1 
0019C2FC                          1918       
0019C2FC                          1919      ;Grab the pixel color RGB value from the array. Since this works on 24-bit files, we cannot load in words or longs,
0019C2FC                          1920      ;so we must load in the pixel values one byte at a time. After loading in the first byte, we must swap in order to put it into it's correct position
0019C2FC                          1921      ;Then for the second byte we must read and roll it left 8 bytes to get THAT color in it's correct position
0019C2FC  1219                    1922      move.b (a1)+, d1
0019C2FE  4841                    1923      swap d1
0019C300  1219                    1924      move.b (a1)+, d1
0019C302  E159                    1925      rol.w #8, d1
0019C304  1219                    1926      move.b (a1)+, d1
0019C306  7050                    1927      move.l #PEN_COLOR_TRAP_CODE, d0
0019C308  4E4F                    1928      trap #15
0019C30A  4241                    1929      clr d1
0019C30C                          1930      
0019C30C                          1931      ;d1 is being used twice in this loop (pixel color, and draw pixel x coordinate),
0019C30C                          1932      ;so copy X-coord value into d4 every time to save, and move back during each iteration of the loop
0019C30C  2204                    1933      move.l d4, d1
0019C30E  7052                    1934      move.l #DRAW_PIXEL_TRAP_CODE, d0
0019C310  4E4F                    1935      trap #15
0019C312                          1936      
0019C312  5241                    1937      addi #1, d1                             ;Increment X-coord
0019C314  2801                    1938      move.l d1, d4                           :Copy X-coord
0019C316  B681                    1939      cmp.l d1, d3 
0019C318  66E0                    1940      bne ContinueRow242
0019C31A  3E14                    1941      move.w (a4), d7                         ;Get file padding, add it to address when we reach end of row
0019C31C  D3C7                    1942      adda.l d7, a1
0019C31E  7200                    1943      move.l #PRINT_TOP_X2, d1                 ;If we reach here, reset X-coord to default value (and copy into d4 to save)
0019C320  7800                    1944      move.l #PRINT_TOP_X2, d4          
0019C322  5382                    1945      subi.l #1, d2                           ;DECREMENT Y-coord, remember we start at BOTTOM not TOP of screen, so subtract
0019C324  D3C6                    1946      adda.l d6, a1
0019C326  0C82 00000000           1947      cmpi.l #PRINT_TOP_Y2, d2
0019C32C  66CC                    1948      bne ContinueRow242
0019C32E                          1949     
0019C32E  4CDF 7FFF               1950      movem.l (sp)+, ALL_REG 
0019C332  4E75                    1951      rts 
0019C334                          1952      
0019C334                          1953   
0019C334                          1954      
0019C334                          1955           
0019C334                          1956  
0019C334                          1957  
0019C334                          1958  ;Mem to store the size of img file
0019C334                          1959  bmpFileSize2 ds.l 1
0019C338                          1960  
0019C338                          1961  ;Mem to store offset of pixel array location in file
0019C338                          1962  bmpPixelOffset2 ds.l 1
0019C33C                          1963  
0019C33C                          1964  ;Mem to store bitmap file width
0019C33C                          1965  bmpFileWidth2 ds.l 1
0019C340                          1966  
0019C340                          1967  ;Mem to store bitmap file height
0019C340                          1968  bmpFileHeight2 ds.l 1
0019C344                          1969  
0019C344                          1970  ;Mem to store Bit Depth of file
0019C344                          1971  bmpBitDepth2 ds.l 1
0019C348                          1972  
0019C348                          1973  ;Mem to store padding for file sizes non-divisible by 4
0019C348                          1974  bmpFilePadding2 ds.w 1
0019C34A                          1975  
0019C34A                          1976  ;Mem to store actual array info of the bitmap, place in same directory as source file
0019C34A                          1977  bmpFile2 INCBIN 'introScreen.bmp'
0027D382                          1978  
0027D382                          1979  
0027D382                          1980  -------------------- end include --------------------
0027D382                          1981      
0027D382                          1982  START:                  
0027D382                          1983  
0027D382  =0000005C               1984  DRAWING_MODE_TRAPCODE equ 92
0027D382  =00000011               1985  DOUBLE_BUFFER_MODE equ 17
0027D382  =0000005E               1986  REPAINT_SCREEN_TRAPCODE equ 94
0027D382  =0000000B               1987  CLEAR_SCREEN_COMMAND equ 11
0027D382  =0000FF00               1988  CLEAR_SCREEN_MAGIC_VAL equ $FF00
0027D382                          1989  
0027D382  4EB9 0019C1AE           1990      jsr drawIntro
0027D388                          1991  drawStartScreen:
0027D388                          1992      
0027D388  7252                    1993      move.l #'R', d1
0027D38A  103C 0013               1994      move.b #GET_USER_INPUT_COMMAND, d0
0027D38E  4E4F                    1995      trap #15
0027D390  2401                    1996      move.l d1, d2
0027D392  0282 000000FF           1997      andi.l #$FF, d2
0027D398  6600 0004               1998      bne initGameLoop
0027D39C  60EA                    1999      bra drawStartScreen
0027D39E                          2000  
0027D39E                          2001  initGameLoop:
0027D39E  4EB9 0027D480           2002      jsr clearScreen
0027D3A4  103C 005C               2003      move.b #DRAWING_MODE_TRAPCODE, d0
0027D3A8  123C 0011               2004      move.b #DOUBLE_BUFFER_MODE, d1
0027D3AC  4E4F                    2005      trap #15
0027D3AE                          2006      
0027D3AE                          2007      ;Initialize the Alien and Player entities
0027D3AE                          2008      ;Also, draw the bitmap and draw the inital scores over it
0027D3AE  4EB8 132E               2009      jsr initAlien
0027D3B2  4EB8 1000               2010      jsr initPlayer
0027D3B6  4EB8 185A               2011      jsr initPlayer2
0027D3BA  4EB8 1682               2012      jsr initLED
0027D3BE  4EB8 1D64               2013      jsr drawBitmap
0027D3C2  4EB8 16C8               2014      jsr updateScore
0027D3C6  4EB8 1C10               2015      jsr updateScore2
0027D3CA                          2016  gameLoop:
0027D3CA                          2017      ;jsr clearScreen
0027D3CA  4EB8 1D20               2018      jsr fakeClearScreen
0027D3CE                          2019      
0027D3CE                          2020      ;First update, then draw the player
0027D3CE  4EB8 101E               2021      jsr updatePlayer    
0027D3D2  4EB8 10E8               2022      jsr drawPlayer
0027D3D6                          2023      
0027D3D6                          2024      ;Update/draw player 2
0027D3D6  4EB8 18A4               2025      jsr updatePlayer2
0027D3DA  4EB8 19C6               2026      jsr drawPlayer2
0027D3DE                          2027          
0027D3DE                          2028      ;Get the number of bullets that are currently being fired.
0027D3DE                          2029      ;If there's 0 bullets, we can skip the Bullet update/draw
0027D3DE  4EB8 1296               2030      jsr checkNumBullets
0027D3E2  6700 000A               2031      beq bulletLoop2
0027D3E6                          2032      
0027D3E6                          2033  bulletLoop:
0027D3E6                          2034      ;If we reach here, draw and update a bullet
0027D3E6  4EB8 12AC               2035      jsr updateBullet
0027D3EA  4EB8 12DA               2036      jsr drawBullet
0027D3EE                          2037      
0027D3EE                          2038  bulletLoop2:
0027D3EE                          2039      *Now check if player 2 has fired any bullets, and update
0027D3EE  4EB8 1B78               2040      jsr checkNumBullets2
0027D3F2  6700 000A               2041      beq continue
0027D3F6                          2042      
0027D3F6  4EB8 1B8E               2043      jsr updateBullet2
0027D3FA  4EB8 1BBC               2044      jsr drawBullet2
0027D3FE                          2045      
0027D3FE                          2046  ;If we have 0 bullets, skip update/draw for them    
0027D3FE                          2047  continue:
0027D3FE                          2048      ;Update, then draw the Alien
0027D3FE  4EB8 1368               2049      jsr updateAlien
0027D402  4EB8 13B0               2050      jsr drawAlien
0027D406                          2051      
0027D406                          2052      ;Call to detect collision between the bullet and the Alien
0027D406  4EB8 1402               2053      jsr detectCollision
0027D40A                          2054      
0027D40A                          2055      ;Call to swap buffers
0027D40A  4EB9 0027D478           2056      jsr swapBuffers
0027D410                          2057      
0027D410                          2058      ;Call to check if the player1 has reached win condition
0027D410  4EB8 17A2               2059      jsr checkP1WinScore
0027D414  6700 000C               2060      beq exitGameLoopWinP1
0027D418                          2061      
0027D418                          2062      ;Call to check if player2 has reached win condition
0027D418  4EB8 17B6               2063      jsr checkP2WinScore
0027D41C  6700 001E               2064      beq exitGameLoopWinP2
0027D420                          2065      
0027D420                          2066      ;If we reach here, restart the game loop
0027D420  60A8                    2067      bra gameLoop
0027D422                          2068  
0027D422                          2069      ;If the player1 wins, clear the screen, print the message, swap buffers, then halt
0027D422                          2070  exitGameLoopWinP1:
0027D422  4EB9 0027D480           2071      jsr clearScreen
0027D428  4EB8 17CA               2072      jsr printP1ScreenWin
0027D42C  4EB9 0027D478           2073      jsr swapBuffers
0027D432  4EB9 0027D456           2074      jsr restartGameLoop
0027D438                          2075      
0027D438  FFFF FFFF               2076      SIMHALT
0027D43C                          2077      
0027D43C                          2078      ;Same as if player1 wins, but instead print player2 message
0027D43C                          2079  exitGameLoopWinP2:
0027D43C  4EB9 0027D480           2080      jsr clearScreen
0027D442  4EB8 17D6               2081      jsr printP2ScreenWin
0027D446  4EB9 0027D478           2082      jsr swapBuffers
0027D44C  4EB9 0027D456           2083      jsr restartGameLoop
0027D452                          2084      
0027D452  FFFF FFFF               2085      SIMHALT
0027D456                          2086    
0027D456                          2087      ;If game is over, check input for Restart  
0027D456                          2088  restartGameLoop:
0027D456  4280                    2089      clr.l d0
0027D458  4281                    2090      clr.l d1
0027D45A  4282                    2091      clr.l d2
0027D45C                          2092      
0027D45C  7252                    2093      move.l #'R', d1
0027D45E  103C 0013               2094      move.b #GET_USER_INPUT_COMMAND, d0
0027D462  4E4F                    2095      trap #15
0027D464  2401                    2096      move.l d1, d2
0027D466  0282 000000FF           2097      andi.l #$FF, d2
0027D46C  6600 0004               2098      bne restartGame
0027D470  60E4                    2099      bra restartGameLoop
0027D472                          2100   
0027D472                          2101  restartGame:
0027D472  4EF9 0027D39E           2102     jmp initGameLoop
0027D478                          2103     
0027D478                          2104  swapBuffers:
0027D478  103C 005E               2105      move.b #REPAINT_SCREEN_TRAPCODE, d0
0027D47C  4E4F                    2106      trap #15
0027D47E  4E75                    2107      rts    
0027D480                          2108      
0027D480                          2109  clearScreen:
0027D480  48E7 FFFE               2110      movem.l ALL_REG,-(sp)
0027D484                          2111  
0027D484  103C 000B               2112      move.b #CLEAR_SCREEN_COMMAND, d0
0027D488  223C 0000FF00           2113      move.l #CLEAR_SCREEN_MAGIC_VAL, d1
0027D48E  4E4F                    2114      trap #15
0027D490                          2115      
0027D490  4CDF 7FFF               2116      movem.l (sp)+,ALL_REG
0027D494                          2117  
0027D494  4E75                    2118      rts
0027D496                          2119  
0027D496                          2120  
0027D496                          2121      END    START       

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDONE              10DE
ADDONE2             19B0
ALIENDOWNVELOCITY   1532
ALIENTABLEX1        1536
ALIENTABLEX2        1586
ALIENTABLEY1        15D6
ALIENTABLEY2        1626
ALIEN_DOWN_ACCELERATION  4
ALIEN_HEIGHT        E
ALIEN_LEFT_VELOCITY  FFFFFFFB
ALIEN_RIGHT_VELOCITY  5
ALIEN_START_X_POSITION  64
ALIEN_TOP_Y_POSITION  2B7A
ALIEN_WIDTH         E
ALL_DATA_REG        FF
ALL_REG             7FFF
APRESSED            1080
BITDEPTH24          1E0E
BITDEPTH242         19C258
BITDEPTH32          1E44
BITDEPTH322         19C292
BITMAP_CHUNK_HEIGHT  F0
BITMAP_CHUNK_HEIGHT2  1E0
BITMAP_CHUNK_TOP_X  0
BITMAP_CHUNK_TOP_X2  0
BITMAP_CHUNK_TOP_Y  0
BITMAP_CHUNK_TOP_Y2  0
BITMAP_CHUNK_WIDTH  28
BITMAP_CHUNK_WIDTH2  280
BITMAP_CHUNK_X_END_POS  28
BITMAP_CHUNK_X_END_POS2  280
BITMAP_CHUNK_Y_START_POS  F0
BITMAP_CHUNK_Y_START_POS2  1E0
BLACK               0
BLUE                FF0000
BMPBITDEPTH         1EF2
BMPBITDEPTH2        19C344
BMPFILE             1EF8
BMPFILE2            19C34A
BMPFILEHEIGHT       1EEE
BMPFILEHEIGHT2      19C340
BMPFILEPADDING      1EF6
BMPFILEPADDING2     19C348
BMPFILESIZE         1EE2
BMPFILESIZE2        19C334
BMPFILEWIDTH        1EEA
BMPFILEWIDTH2       19C33C
BMPPIXELOFFSET      1EE6
BMPPIXELOFFSET2     19C338
BMP_BITDEPTH_OFFSET  1C
BMP_FILE_SIZE_OFFSET  2
BMP_HEIGHT_OFFSET   16
BMP_START_ADDRESS_OFFSET  A
BMP_WIDTH_OFFSET    12
BOTTOM_SIDE_OF_SCREEN  1F4
BOTTOM_Y_COORDINATE  32
BOTTOM_Y_COORDINATE2  DC
BULLET2ACTIVE       1B74
BULLET2VELOCITY     1C0C
BULLETACTIVE        1292
BULLETLOOP          27D3E6
BULLETLOOP2         27D3EE
BULLETTABLE2X1      1A34
BULLETTABLE2X2      1A84
BULLETTABLE2Y1      1AD4
BULLETTABLE2Y2      1B24
BULLETTABLEX1       1152
BULLETTABLEX2       11A2
BULLETTABLEY1       11F2
BULLETTABLEY2       1242
BULLETVELOCITY      132A
BULLET_ACCELERATION  1
BULLET_HEIGHT       10
BULLET_STARTING_X_POSITION  28
BULLET_TOP_Y_POSITION  1B328
BULLET_VELOCITY     2D
BULLET_WIDTH        10
CHECKBULLET2        1452
CHECKNUMBULLETS     1296
CHECKNUMBULLETS2    1B78
CHECKP1WINSCORE     17A2
CHECKP2WINSCORE     17B6
CLEARSCREEN         27D480
CLEAR_SCREEN_COMMAND  B
CLEAR_SCREEN_MAGIC_VAL  FF00
CONTINUE            27D3FE
CONTINUEROW24       1EA8
CONTINUEROW242      19C2FA
CONTINUEROW32       1E78
CONTINUEROW322      19C2CA
COORDINATETABLE2Y1  1D02
COORDINATETABLE2Y2  1D09
COORDINATETABLEOFFSET  1808
COORDINATETABLEOFFSET2  1D10
COORDINATETABLEX1   17EC
COORDINATETABLEX2   17F3
COORDINATETABLEY1   17FA
COORDINATETABLEY2   1801
COORDINATE_OFFSET   6
DELETE              14AA
DELETE2             14DC
DELETEALIEN         13A6
DELETEBULLET        1322
DELETEBULLET2       1C04
DETECTCOLLISION     1402
DISPLAY_FILE_TRAP_CODE  3A
DOUBLE_BUFFER_MODE  11
DPRESSED            1070
DRAWALIEN           13B0
DRAWBITMAP          1D64
DRAWBULLET          12DA
DRAWBULLET2         1BBC
DRAWING_MODE_TRAPCODE  5C
DRAWINTRO           19C1AE
DRAWPLAYER          10E8
DRAWPLAYER2         19C6
DRAWSEGMENT         171C
DRAWSEGMENT2        1C6C
DRAWSTARTSCREEN     27D388
DRAW_CIRCLE_COMMAND  58
DRAW_PIXEL_TRAP_CODE  52
DRAW_RECTANGLE_COMMAND  57
EXITGAMELOOPWINP1   27D422
EXITGAMELOOPWINP2   27D43C
FAKECLEARSCREEN     1D20
FILL_COLOR_COMMAND  51
FIREPRESSED         1952
FUSCHIA             FF00FF
GAMELOOP            27D3CA
GENERATERANDOMSPAWNPOINT  1516
GET_PIXEL_COLOR_COMMAND  53
GET_TIME_COMMAND    8
GET_USER_INPUT_COMMAND  13
GREEN               8000
INITALIEN           132E
INITGAMELOOP        27D39E
INITLED             1682
INITPLAYER          1000
INITPLAYER2         185A
LEFTPRESSED         193C
LEFT_ARROW          25
LEFT_X_COORDINATE   14
LOOP                1712
LOOP2               1C62
LOSEFLAG            167E
MIDDLE_Y_COORDINATE  28
MIDDLE_Y_COORDINATE2  D2
MOREPADDING         1856
NUMBULLETS          114E
NUMBULLETS2         1A30
OPEN_EXISTING_FILE_TRAP_CODE  33
OPEN_NEW_FILE_TRAP_CODE  34
PADDING             1D1C
PEN_COLOR_TRAP_CODE  50
PLAYER1SCORE        1676
PLAYER1STRING       180B
PLAYER2SCORE        167A
PLAYER2STRING       1831
PLAYER2X1           1A20
PLAYER2X2           1A24
PLAYER2Y1           1A28
PLAYER2Y2           1A2C
PLAYER2_STARTING_X_POSITION  1B224
PLAYERX1            113E
PLAYERX2            1142
PLAYERY1            1146
PLAYERY2            114A
PLAYER_HEIGHT       14
PLAYER_LEFT_VELOCITY  FFFFFFDD
PLAYER_RIGHT_VELOCITY  23
PLAYER_STARTING_X_POSITION  28
PLAYER_TOP_Y_POSITION  1B350
PLAYER_WIDTH        14
PRINTFLAG           180A
PRINTFLAG2          1D18
PRINTOFFSET         1809
PRINTOFFSET2        1D14
PRINTP1SCREENWIN    17CA
PRINTP2SCREENWIN    17D6
PRINT_OFFSET        F
PRINT_TEXT_COMMAND  E
PRINT_TOP_X         0
PRINT_TOP_X2        0
PRINT_TOP_Y         0
PRINT_TOP_Y2        0
PURPLE              800080
RANDOM_MASK         FFFFFF
READDIGIT           1700
READDIGIT2          1C50
READ_FILE_TRAP_CODE  35
RED                 FF
REPAINT_SCREEN_TRAPCODE  5E
RESTARTGAME         27D472
RESTARTGAMELOOP     27D456
RETURN              10E6
RETURN2             19BE
RETURNFROMDELETE    12D2
RETURNFROMDELETE2   1BB4
RIGHTPRESSED        1926
RIGHT_ARROW         27
RIGHT_SIDE_OF_SCREEN  280
RIGHT_X_COORDINATE  1E
SET_FILL_COLOR_COMMAND  51
SET_PEN_COLOR_COMMAND  50
SEVENSEGMENTTABLE   17E2
SHIFT               1752
SHIFT2              1CA2
SKIP                1510
SPACEPRESSED        1090
START               27D382
STOPPRINTING        178E
STOPPRINTING2       1CE6
SUBTRACTONE         10D6
SUBTRACTONE2        19A2
SUM_OF_RADII        F
SUM_OF_RADII_SQUARED  E1
SWAPBUFFERS         27D478
TEST_NUMBER         39
TOP_SIDE_OF_SCREEN  0
TOP_Y_COORDINATE    1E
TOP_Y_COORDINATE2   C8
UPDATEALIEN         1368
UPDATEBULLET        12AC
UPDATEBULLET2       1B8E
UPDATEPLAYER        101E
UPDATEPLAYER2       18A4
UPDATESCORE         16C8
UPDATESCORE2        1C10
UPPERSWAP           1764
UPPERSWAP2          1CB4
WHITE               FFFFFF
WIN_SCORE           A
ZERO_KEYPAD         2D
